<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java运行时数据区]]></title>
    <url>%2FJava%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F2550534154.html</url>
    <content type="text"><![CDATA[JDK8 版本]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>图解运行时数据区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Taro+Taro UI+DvaJS开发小程序]]></title>
    <url>%2FTaro%2BTaro%20UI%2BDvaJS%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F1857577861.html</url>
    <content type="text"><![CDATA[Taro+Taro UI+DvaJS 技术 Taro 多端统一开发解决方案。 Taro UI 一套基于 Taro 框架开发的多端 UI 组件库。 DvaJS 一个基于reudx和redux-saga的数据流方案，内置了react-router和fetch，可以理解为一个轻量级的应用框架。 为什么选择 Taro我本身对 React 技术有深入了解，深深被 React 所折服，写起前端来优雅舒服。然后 Taro 是基于 React 的，所以可以用 React 的大部分语法来开发小程序，Taro 不仅仅局限于微信小程序，还能多平台开发编译打包。DvaJS 是在 React 的基础上的一个框架，非常简单易用，写起前端很有逻辑性。 搭建过程我先放出我成功搭建的仓库。 coding 仓库: coding:weappDemo github 仓库: github:weappDemo 如果按照我以下的教程搭建不成功，可以去我的仓库查看(注意文件的路径和 package.json 文件！)。 1.初始化 Taro 项目 taro init 项目名 等待初始化完成。 yarn add @tarojs/async-await yarn add taro-ui yarn add redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger yarn add dva-core dva-loading 建议使用yarn安装相应的包。 如果开发完成后进行打包，没有样式，可能要全局安装Taro UI。 yarn global add taro-ui 2.创建项目文件项目目录： ① 在/src/utils 下创建 dva.js 文件。 123456789101112131415161718192021222324252627282930313233import &#123; create &#125; from "dva-core";//import &#123; createLogger &#125; from 'redux-logger';import createLoading from "dva-loading";let app;let store;let dispatch;function createApp(opt) &#123; // redux日志 // opt.onAction = [createLogger()]; app = create(opt); app.use(createLoading(&#123;&#125;)); if (!global.registered) opt.models.forEach((model) =&gt; app.model(model)); global.registered = true; app.start(); store = app._store; app.getStore = () =&gt; store; dispatch = store.dispatch; app.dispatch = dispatch; return app;&#125;export default &#123; createApp, getDispatch() &#123; return app.dispatch; &#125;,&#125;; ② 在/src/utils 下创建 request.js 文件，封装请求(你也可以自己封装)。 123456789101112131415161718192021222324252627282930313233import Taro from "@tarojs/taro";// const baseUrl = 'https://xxxx.com/api/'//你也可以自己封装requestexport default (options = &#123; method: "GET", data: &#123;&#125; &#125;) =&gt; &#123; return Taro.request(&#123; // url: baseUrl + options.url, url: options.url, data: &#123; ...options.data, &#125;, header: &#123; "Content-Type": "application/json", &#125;, method: options.method.toUpperCase(), &#125;).then((res) =&gt; &#123; const &#123; statusCode, data &#125; = res; if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) &#123; if (data.msg !== "success") &#123; // Taro.showToast(&#123; // // title: `$&#123;res.data.msg&#125;~` || res.data.code, // title: res.data.code, // icon: 'none', // mask: true, // &#125;); &#125; return data; &#125; else &#123; throw new Error(`网络请求错误，状态码$&#123;statusCode&#125;`); &#125; &#125;);&#125;; ③/src/models/index.js。 12345//import各个pages下的modelimport index from "../pages/index/model";import xxx from "../pages/页面名/model";export default [index, xxx]; ④ 在/src/app.jsx 中引入 dva.js。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//需要自己importimport "@tarojs/async-await";import &#123; Provider &#125; from "@tarojs/redux";import dva from "./utils/dva";import models from "./models";//---必须引入以上---import Taro, &#123; Component &#125; from "@tarojs/taro";import Index from "./pages/index";import "./app.scss";//引入dva//---const dvaApp = dva.createApp(&#123; initialState: &#123;&#125;, models: models,&#125;);const store = dvaApp.getStore();//---// 如果需要在 h5 环境中开启 React Devtools// 取消以下注释：// if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.TARO_ENV === 'h5') &#123;// require('nerv-devtools')// &#125;class App extends Component &#123; config = &#123; pages: ["pages/index/index"], window: &#123; backgroundTextStyle: "light", navigationBarBackgroundColor: "#fff", navigationBarTitleText: "WeChat", navigationBarTextStyle: "black", &#125;, &#125;; componentDidMount() &#123;&#125; componentDidShow() &#123;&#125; componentDidHide() &#123;&#125; componentDidCatchError() &#123;&#125; // 注意要用&lt;Provider&gt;标签 // 在 App 类中的 render() 函数没有实际作用 // 请勿修改此函数 render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Index /&gt; &lt;/Provider&gt; ); &#125;&#125;Taro.render(&lt;App /&gt;, document.getElementById("app")); ⑤/src/pages/页面名/service.js 的写法。 123456789import Request from "../../utils/request";export const demo = (data) =&gt; &#123; return Request(&#123; url: "路径", method: "POST", data, &#125;);&#125;; 3.创建页面模板文件 template.js创建 template.js 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * pages模版快速生成脚本,执行命令 npm run temp `页面名` */const fs = require("fs");const dirName = process.argv[2];if (!dirName) &#123; console.log("文件夹名称不能为空！"); console.log("示例：npm run tep test"); process.exit(0);&#125;// 页面模版const indexTep = `import Taro, &#123; Component &#125; from '@tarojs/taro';import &#123; View &#125; from '@tarojs/components';import &#123; connect &#125; from '@tarojs/redux';import './index.scss';@connect((&#123;$&#123;dirName&#125;&#125;) =&gt; (&#123; ...$&#123;dirName&#125;,&#125;))export default class $&#123;titleCase(dirName)&#125; extends Component &#123; config = &#123; navigationBarTitleText: '$&#123;dirName&#125;', &#125;; componentDidMount = () =&gt; &#123; &#125;; render() &#123; return ( &lt;View className='$&#123;dirName&#125;-page'&gt; $&#123;dirName&#125; &lt;/View&gt; ) &#125;&#125;`;// scss文件模版const scssTep = `.$&#123;dirName&#125;-page &#123;&#125;`;// model文件模版const modelTep = `import * as $&#123;dirName&#125;Api from './service';export default &#123; namespace: '$&#123;dirName&#125;', state: &#123; &#125;, effects: &#123; * effectsDemo(_, &#123; call, put &#125;) &#123; const &#123; status, data &#125; = yield call($&#123;dirName&#125;Api.demo, &#123;&#125;); if (status === 'ok') &#123; yield put(&#123; type: 'save', payload: &#123; topData: data, &#125; &#125;); &#125; &#125;, &#125;, reducers: &#123; save(state, &#123; payload &#125;) &#123; return &#123; ...state, ...payload &#125;; &#125;, &#125;,&#125;;`;// service页面模版const serviceTep = `import Request from '../../utils/request';export const demo = (data) =&gt; &#123; return Request(&#123; url: '路径', method: 'POST', data, &#125;);&#125;;`;fs.mkdirSync(`./src/pages/$&#123;dirName&#125;`); // mkdir $1process.chdir(`./src/pages/$&#123;dirName&#125;`); // cd $1fs.writeFileSync("index.js", indexTep);fs.writeFileSync("index.scss", scssTep);fs.writeFileSync("model.js", modelTep);fs.writeFileSync("service.js", serviceTep);console.log(`模版$&#123;dirName&#125;已创建,请手动增加models`);function titleCase(str) &#123; const array = str.toLowerCase().split(" "); for (let i = 0; i &lt; array.length; i++) &#123; array[i] = array[i][0].toUpperCase() + array[i].substring(1, array[i].length); &#125; const string = array.join(" "); return string;&#125; 然后在 package.json 下加入脚本。 1234"scripts": &#123; ..., "temp": "node template"&#125; 在终端中执行 npm run temp 页面名 即可创建页面模板。 当然你可以手动创建。 注意１.你需要熟悉 React 语法，DvaJS 框架的开发流程，Taro 的使用和 Taro-UI 的引入。 ２.如果要预览开发的效果，你需要去各个小程序的平台下载开发工具，然后导入开发生成的 dist 项目文件夹。 ３.开发时最好使用手机预览一下效果，因为模拟器和真机有一定的误差，开发完成打包后也应该同时在模拟器和手机上预览。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Taro</tag>
        <tag>Taro UI</tag>
        <tag>DvaJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA虚拟机]]></title>
    <url>%2FJAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%2F2158833482.html</url>
    <content type="text"><![CDATA[JVM1.JVM 的主要组成部分及其作用？ 类加载器(ClassLoader) 运行时数据区(Runtime Data Area) 执行引擎(Execution Engine) 本地库接口(Native Interface) 组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能 2.JVM 运行时数据区？不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范Java 虚拟机规范规定的区域分为以下 5 个部分： 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成 Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的 Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据 3.堆栈的区别？ 堆 栈 功能 存放对象 执行程序 共享性 线程共享 线程私有 空间大小 远大于栈 远小于堆 4.什么是双亲委派模型？在介绍双亲委派模型之前先说下类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象 类加载器分类： 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库 其他类加载器： 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext 目录或 Java. ext. dirs 系统变量指定的路径中的所有类库 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成 每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类 5.类加载的执行过程？类装载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入 检查：检查加载的 class 文件的正确性 准备：给类中的静态变量分配内存空间 解析：虚拟机将常量池中的符号引用替换成直接引用的过程 符号引用就理解为一个标示，而在直接引用直接指向内存中的地址 初始化：对静态变量和静态代码块执行初始化工作 6. 怎么判断对象是否可以被回收？一般有两种方法来判断： 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收 它有一个缺点不能解决循环引用的问题 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链 当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的 7.JAVA 中都有哪些引用类型？ 强引用：发生 gc 的时候不会被回收 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知 8.JVM 有哪些垃圾回收算法？ 标记-清除算法：标记无用对象，然后进行清除回收 缺点：效率不高，无法清除垃圾碎片 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉 缺点：内存使用率不高，只有原来的一半 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存 缺点：内存变动频繁，效率上比复制算法差很多 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法 9.JVM 有哪些垃圾回收器？ Serial：最早的单线程串行垃圾回收器 Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案 ParNew：是 Serial 的多线程版本 Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量 Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项 10. CMS 垃圾回收器？CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器对于要求服务器响应速度的应用上，这种垃圾回收器非常适合在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低 11.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是复制算法复制算法的优点是效率高，缺点是内存利用率低老年代回收器一般采用的是标记-整理的算法进行垃圾回收 12.分代垃圾回收器是怎么工作的？分代回收器有两个分区：堆空间=新生代(1/3)+老生代(2/3)老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3 新生代=Eden(8/10)+Survivor(From(1/10)+To(1/10))新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 存活的对象放入 To Survivor 区 清空 Eden 和 From Survivor 分区 From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代大对象也会直接进入老生代老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法以上这些循环往复就构成了整个分代垃圾回收的整体执行流程 13.JVM 调优的工具？JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具 jconsole：用于对 JVM 中的内存、线程和类等进行监控 jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等 14.常用的 JVM 调优的参数都有哪些？ -Xms2g：初始化推大小为 2g -Xmx2g：堆最大内存为 2g -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4 -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2 –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合 -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合 -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合 -XX:+PrintGC：开启打印 gc 信息 -XX:+PrintGCDetails：打印 gc 详细信息]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架相关]]></title>
    <url>%2F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%2F4193427372.html</url>
    <content type="text"><![CDATA[Spring/SpringMVC1.为什么要使用 Spring？ spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象，更轻松的实现了程序的解耦 spring 提供了事务支持，使得事务操作变的更加方便 spring 提供了面向切片编程，这样可以更方便的处理某一类的问题 更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等 2.什么是 aop？aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术简单来说就是统一处理某一“切面”(类)的问题的编程思想，比如统一处理日志、异常等 3.什么是 ioc？ioc：Inversion of Control(中文：控制反转)是 Spring 的核心，对于 spring 框架来说，就是由 Spring 来负责控制对象的生命周期和对象间的关系简单来说，控制指的是当前对象对内部成员的控制权控制反转指的是，这种控制权不由当前对象管理了，由其他(类，第三方容器)来管理 4.Spring 有哪些主要模块？ spring core：框架的最基础部分，提供 ioc 和依赖注入特性 spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法 spring dao：Data Access Object 提供了 JDBC 的抽象层 spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等 spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现 5.Spring 常用的注入方式有哪些？ setter 属性注入 构造方法注入 注解方式注入 6.Spring 中的 bean 是线程安全吗？实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了 有状态就是有数据存储功能 无状态就是不会保存数据 7.Spring 支持几种 bean 的作用域？ singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值 prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作 Web 环境下的作用域： request：每次 http 请求都会创建一个 bean session：同一个 http session 共享一个 bean 实例 global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session 注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销 8.Spring 自动装配 bean 有哪些方式？ no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配 byName：它根据 bean 的名称注入对象依赖项 byType：它根据类型注入对象依赖项 构造函数：通过构造函数来注入依赖项，需要设置大量的参数 autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配 9.Spring 事务实现方式有哪些？ 声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解） 编码方式：提供编码的形式管理和维护事务 10. Spring 的事务隔离？spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致： ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么 ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读） ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别 ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别 ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A 不可重复读 ：是指在一个事务内，多次读同一数据 幻读 ：指同一个事务内多次查询返回的结果集不一样比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了 11. SpringMVC 运行流程？ spring mvc 先将请求发送给 DispatcherServlet DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller DispatcherServlet 再把请求提交到对应的 Controller Controller 进行业务逻辑处理后，会返回一个 ModelAndView Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象 视图对象负责渲染返回给客户端 12. SpringMVC 有哪些组件？ 前置控制器 DispatcherServlet 映射控制器 HandlerMapping 处理器 Controller 模型和视图 ModelAndView 视图解析器 ViewResolver 13. @RequestMapping 的作用是什么？将 http 请求映射到相应的类/方法上 14. @Autowired 的作用是什么？@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作通过@Autowired 的使用来消除 set/get 方法 Spring Boot/Spring Cloud15. 什么是 spring boot？spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的 16. 为什么要用 spring boot？ 配置简单 独立运行 自动装配 无代码生成和 xml 配置 提供应用监控 易上手 提升开发效率 17. spring boot 核心配置文件是什么？spring boot 核心的两个配置文件： bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖 application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置 18. spring boot 配置文件有哪几种类型？它们有什么区别？配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同.properties 配置如下： 1spring. RabbitMQ. port=5672 .yml 配置如下： 123spring: RabbitMQ: port: 5672 .yml 格式不支持 @PropertySource 注解导入 19. spring boot 有哪些方式可以实现热部署？ 使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true 使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译 20. jpa 和 hibernate 有什么区别？jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现 21. 什么是 spring cloud？spring cloud 是一系列框架的有序集合它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署 22. spring cloud 断路器的作用是什么？在分布式架构中，断路器模式的作用也是类似的当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延 23. spring cloud 的核心组件有哪些？ Eureka：服务注册于发现 Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求 Ribbon：实现负载均衡，从一个服务的多台机器中选择一台 Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题 Zuul：网关管理，由 Zuul 网关转发请求给对应的服务 MyBatis24. MyBatis 中 #{}和 ${}的区别是什么？ \#{}是预编译处理 ${}是字符替换 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全 25. MyBatis 有几种分页方式？分页方式：逻辑分页和物理分页逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式 26. RowBounds 是一次性查询全部结果吗？为什么？RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出 27. MyBatis 逻辑分页和物理分页的区别是什么？ 逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大 物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题 28. MyBatis 是否支持延迟加载？延迟加载的原理是什么？MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理 29. MyBatis 的一级缓存和二级缓存？ 一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的 二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个 SQLSession 之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态) 开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库 缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 30. MyBatis 和 hibernate 的区别有哪些？ 灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便 可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差 学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低 二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存 31. MyBatis 有哪些执行器（Executor）？MyBatis 有三种基本的 Executor 执行器： SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象 ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象 BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同 32. MyBatis 分页插件的实现原理是什么？分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数 MySQL33. 数据库的三范式是什么？ 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性 第三范式：任何非主属性不依赖于其它非主属性 34. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？ 表类型如果是 MyISAM ，那 id 就是 8 表类型如果是 InnoDB，那 id 就是 6 InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失 35. 如何获取当前数据库版本？使用 select version() 获取当前 MySQL 数据库版本 36. 说一下 ACID 是什么？ Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节 事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样 即，事务不可分割、不可约简 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏 这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable） Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 37. char 和 varchar 的区别是什么？ char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节 优点：效率高缺点：占用空间适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适 varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度 所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡 38. float 和 double 的区别是什么？ float 最多可以存储 8 位的十进制数，并在内存中占 4 字节 double 最可可以存储 16 位的十进制数，并在内存中占 8 字节 39. MySQL 的内连接、左连接、右连接有什么区别？内连接：inner join，把匹配的关联数据显示出来左连接：left join，左边的表全部显示出来，右边的表显示出符合条件的数据右连接：right join，右连接与左连接正好相反 40. MySQL 索引是怎么实现的？索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的 41. 怎么验证 MySQL 的索引是否满足需求？使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求explain 语法：explain select * from table where type=1 42. 数据库的事务隔离？MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加： transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读） READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读） REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读） SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A 不可重复读 ：是指在一个事务内，多次读同一数据 幻读 ：指同一个事务内多次查询返回的结果集不一样比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录,这就好像产生了幻觉发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了 43. MySQL 常用的引擎？ InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统 MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引 但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表 由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的 MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键 因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低 不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选 44. MySQL 的行锁和表锁？MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高 45. 乐观锁和悲观锁？ 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放 数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁 46. MySQL 问题排查都有哪些手段？ 使用 show processlist 命令查看当前所有连接信息 使用 explain 命令查询 SQL 语句执行计划 开启慢查询日志，查看慢查询的 SQL 47. 如何做 MySQL 的性能优化？ 为搜索字段创建索引 避免使用 select *，列出需要查询的字段 垂直分割分表 选择正确的存储引擎 Redis48. Redis 是什么？都有哪些使用场景？Redis 是一个使用 C 语言开发的高速缓存数据库Redis 使用场景： 记录帖子点赞数、点击数、评论数 缓存近期热帖 缓存文章详情信息 记录用户会话信息 49. Redis 有哪些功能？ 数据缓存功能 分布式锁的功能 支持数据持久化 支持事务 支持消息队列 50. Redis 为什么是单线程的？因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表 51. 什么是缓存穿透？怎么解决？缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透 解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟 52. Redis 支持的数据类型有哪些？Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合） 53. jedis 和 Redisson 有哪些区别？ jedis：提供了比较全面的 Redis 命令的支持 Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性 54. 怎么保证缓存和数据库数据的一致性？ 合理设置缓存的过期时间 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性 55. Redis 持久化有几种方式？Redis 的持久化有两种方式，或者说有两种策略： RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储 AOF（Append Only File）：每一个收到的写命令都通过 write 函数追加到文件中 56. Redis 怎么实现分布式锁？Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁 57. Redis 分布式锁有什么缺陷？Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题 58. Redis 如何做内存优化？尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用 比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储 59. Redis 淘汰策略有哪些？ volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰 allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据 60. Redis 常见的性能问题有哪些？该如何解决？ 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照 Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MyBatis</tag>
        <tag>MySQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA相关知识]]></title>
    <url>%2FJAVA%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F1934514025.html</url>
    <content type="text"><![CDATA[JAVA 基础1.JDK 与 JRE 的区别 JDK：JAVA 开发工具包，具有 JAVA 的开发环境和运行环境 JRE：JAVA运行环境。 JDK 包含 JRE，还有 Javac 编译器和 Java 程序调试和分析的工具 2.==和 equals 的区别== 基本类型：比较值是否相同 引用类型：比较引用是否相同 equalsequals 其实就是==，不过 String 和 Integer 等重写了 equals 方法，将其变成了值比较 1234//equals源码public boolean equals(Object obj)&#123; return (this == obj)&#125; String 重写了 Object 的 equals 方法，将引用比较改为值比较 12345678910111213141516171819202122//String重写equalspublic boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 3.两个对象的 hashCode() 相同，则 equals() 也一定为 true?不对，两个对象的 hashCode()相同，equals()不一定为 true在散列表(hash)中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等 4.final 在 JAVA 中的作用 final 修饰的类叫最终类，该类不能被继承 final 修饰的方法不能被重写 final 修饰的变量叫常亮，常亮必须初始化，初始化之后的值不能被修改 5.JAVA 中的 Math.round(-1.5)等于？等于-1,在数轴上取值，中间值(0.5)向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃 6.String 属于基础的数据类型？不属于，String 属于对象基础类型(8 种)：byte，boolean，char，short，int，float，long，double 7.JAVA 中操作字符串的类和它们之间的区别？ String StringBuffer StringBuilder 说明 声明的对象不可变，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，经常改变字符串内容的情况下最好不要使用 在原有对象的基础上操作，建议多线程使用 在原有对象的基础上操作，建议单线程使用 线程安全 否 是 否 性能 弱 弱 强 8.String str=”i”与 String str=new String(“i”)一样？不一样，内存分配方式不同 String str=”i” //JAVA 虚拟机将其分配到常量池 String str=new String(“i”) //分配到堆内存中 9.字符串反转使用 StringBuilder 或者 stringBuffer 的 reverse() 方法 10.String 类的常用方法 indexOf()：返回指定字符的索引 charAt()：返回指定索引处的字符 replace()：字符串替换 trim()：去除字符串两端空白 split()：分割字符串，返回一个分割后的字符串数组 getBytes()：返回字符串的 byte 类型数组 length()：返回字符串长度 toLowerCase()：将字符串转成小写字母 toUpperCase()：将字符串转成大写字符 substring()：截取字符串 equals()：字符串比较 11.抽象类必须要有抽象方法？不需要 12.普通类和抽象类的区别 普通类 抽象类 抽象方法 不能包含 可以包含 实例化 直接实例化 不能直接实例化 13.抽象类能使用 final 修饰？不能抽象类就是让其它类继承的，定义成 final 表示该类不能被继承，产生矛盾 14.接口和抽象类的什么区别？ 接口 抽象类 实现 implements extends 构造函数 不能有 有 实现数量 多个 一个 访问修饰符 默认 public 任意 15.JAVA 中 IO 流分几种？ 按功能：输入流、输出流 按类型：字节流、字符流 字节流：按 8 位传输以字节为单位输入输出数据字符流：按 16 位传输以字符为单位输入输出数据 16.BIO、NIO、AIO 有什么区别？ BIO NIO AIO 说明 Block IO，同步阻塞 IO，传统 IO Non IO，同步非阻塞 IO，传统 IO 升级版 Asynchronous IO，异步非阻塞 IO，NIO 的升级版 特点 模式简单方便，并发能力低 通过 Channel(通道)通讯，多路复用 基于事件和回调机制 17. Files 的常用方法都有哪些？ Files. exists()：检测文件路径是否存在 Files. createFile()：创建文件 Files. createDirectory()：创建文件夹 Files. delete()：删除一个文件或目录 Files. copy()：复制文件 Files. move()：移动文件 Files. size()：查看文件个数 Files. read()：读取文件 Files. write()：写入文件 JAVA 容器18. Java 容器都有哪些？Collection List ArrayList LinkedList Vector Stack Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap HashTable 19. Collection 和 Collections 有什么区别？ Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。 Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。 20. List、Set、Map 之间的区别是什么？ 元素有序 允许元素重复 List 是 是 AbstractSet 否 否 HashSet 否 否 TreeSet 是(二叉树排序) 否 AbstractMap 否 key 值必须唯一，value 可重复 HashMap 否 key 值必须唯一，value 可重复 TreeMap 是(二叉树排序) key 值必须唯一，value 可重复 21. HashMap 和 Hashtable 有什么区别？ HashMap HashTable 存储 key 和 value 为 null 不允许为 null 线程安全 不安全 安全 使用 单线程用 HashMap 替代 HashTable，多线程用 ConcurrentHashMap 替代 HashTable 是保留类不建议使用 22. 如何决定使用 HashMap 还是 TreeMap？ HashMap：在 Map 中插入、删除、定位一个元素这类操作，相对而言 HashMap 的插入会更快 TreeMap：对一个 key 集合进行有序的遍历 23. HashMap 的实现原理？基于 Hash 算法实现，通过 put(key,value)存储，get(key)获取当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里当计算出的 hash 值相同时，我们称之为 hash 冲突HashMap 的做法是用链表和红黑树存储相同 hash 值的 value当 hash 冲突的个数比较少时，使用链表否则使用红黑树 24.HashSet 的实现原理？基于 HashMap 实现HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成HashSet 不允许重复的值 25. ArrayList 和 LinkedList 的区别是什么？ Ａ rrayList LinkedList 数据结构 动态数组 双向链表 随机访问效率 高 低 增加和删除效率 低 高 使用 频繁读取集合中的元素 插入和删除操作较多 26. 如何实现数组和 List 之间的转换？ 数组转 List：使用 Arrays. asList(array) 进行转换 List 转数组：使用 List 自带的 toArray() 方法 27.ArrayList 和 Vector 的区别是什么？ ArrayList Vector 线程安全 不安全 安全 性能 优 劣 扩容 每次增加 50% 每次增加 1 倍 28. Array 和 ArrayList 有何区别？ ArrayList Array 存储 对象 基本数据类型和对象 大小 自动扩展 固定 方法 addAll、removeAll、iteration 等方法特有 较之少 29. 在 Queue 中 poll()和 remove()有什么区别？ 相同点：都是返回第一个元素，并在队列中删除返回的对象 不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常 30. 哪些集合类是线程安全的？ 线程安全 非线程安全 Vector、HashTable、Stack、ConcurrentHashMap HashMap 31. 迭代器 Iterator 是什么？Iterator 接口提供遍历任何 Collection 的接口可以从一个 Collection 中使用迭代器方法来获取迭代器实例迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素 32. Iterator 怎么使用？有什么特点？123456List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String obj = it.next(); System.out.println(obj);&#125; 特点：更加安全，它可以确保在当前遍历的集合元素被更改的时候，就抛出 ConcurrentModificationException 异常 33. Iterator 和 ListIterator 有什么区别？ Iterator ListIterator 说明 遍历集合中的元素 从 Iterator 接口继承，添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置 遍历集合类 Set、List LIst 遍历方式 单向遍历 双向遍历(向前/后遍历) 34. 怎么确保一个集合不能被修改？可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常 123456//例子List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("x");Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist.add("y"); // 运行时此行报错System.out.println(list.size()); 多线程35. 并行和并发有什么区别？ 并行：多个处理器或多核处理器同时执行多个任务 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流执行，从逻辑上来看那些任务是同时执行 并行=两个队列和两台机器并发=两个队列和一台机器 36. 线程和进程的区别？一个程序下至少有一个进程一个进程下至少有一个线程一个进程下可以有多个线程来增加程序的执行速度 37. 守护线程是什么？守护线程是运行在后台的一种特殊进程独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件JAVA 中的垃圾回收线程就是特殊的守护线程 38. 创建线程有哪几种方式？创建线程有三种方式： 继承 Thread 重写 run 方法 实现 Runnable 接口 实现 Callable 接口 39. Runnable 和 Callable 有什么区别？Runnable 没有返回值Callable 可以拿到返回值，可以看作是 Runnable 的补充 40. 线程有哪些状态？ NEW 尚未启动 RUNNABLE 正在执行中 BLOCKED 阻塞的（被同步锁或者 IO 锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执行完成 41. sleep() 和 wait() 有什么区别？ sleep() wait() 类 Thread Object 释放锁 不释放 释放 用法 时间到会自动恢复 可以使用 notify()/notifyAll()直接唤醒 42. notify()和 notifyAll()有什么区别？ notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制 notifyAll()会唤醒所有的线程，notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争 43. 线程的 run() 和 start() 有什么区别？ run() 方法用于执行线程的运行时代码，run() 可以重复调用 start() 方法用于启动线程，start() 只能调用一次 44. 创建线程池有哪几种方式？线程池创建有七种方式，最核心的是最后一种： newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目 newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列 newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度 newScheduledThreadPool(int corePoolSize)：和 newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程 newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序 ThreadPoolExecutor()：是最原始的线程池创建，上面 1-3 创建方式都是 ThreadPoolExecutor 的封装 45. 线程池都有哪些状态？ RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程 TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated() TERMINATED：terminated()方法结束后，线程池的状态就会变成这个 46. 线程池中 submit() 和 execute() 方法有什么区别？ submit()：可以执行 Runnable 和 Callable 类型的任务 execute()：只能执行 Runnable 类型的任务 Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值 47. 在 Java 程序中怎么保证多线程的运行安全？ 方法一：使用安全类，比如 Java. util. concurrent 下的类 方法二：使用自动锁 synchronized 方法三：使用手动锁 Lock 1234567891011//手动锁Lock lock = new ReentrantLock();lock.lock();try &#123; System.out.println("获得锁");&#125; catch (Exception e) &#123; // TODO: handle exception&#125; finally &#123; System.out.println("释放锁"); lock.unlock();&#125; 48. 多线程中 synchronized 锁升级的原理是什么？synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级 锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗 49. 什么是死锁？当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，称为死锁 50. 怎么防止死锁？ 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁 尽量使用 Java. util. concurrent 并发类代替自己手写锁 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁 尽量减少同步的代码块 51. ThreadLocal 是什么？有哪些使用场景？ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本ThreadLocal 的经典使用场景是数据库连接和 session 管理等 52. synchronized 底层实现原理？synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能 53. synchronized 和 volatile 的区别是什么？ synchronized volatile 修饰 类、方法、代码段 变量修饰符 事务性 可以保证变量的修改可见性和原子性 仅能实现变量的修改可见性，不能保证原子性 线程阻塞 可能会 不会 54. synchronized 和 Lock 有什么区别？ synchronized Lock 修饰对象 类、方法、代码块 代码块 释放锁和释放锁的方式 自动，发生异常自动释放，不会造成死锁 手动，使用不当没有 unLock()去释放锁会造成死锁 是否感知获取锁 是 否 55. synchronized 和 ReentrantLock 区别是什么？synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进 主要区别如下： ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作 ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁 ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等 56. atomic 的原理？atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升 反射57. 什么是反射？反射是在运行状态中 对于任意一个类，都能够知道这个类的所有属性和方法 对于任意一个对象，都能够调用它的任意一个方法和属性 这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制 58. 什么是 Java 序列化？什么情况下需要序列化？Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来以下情况需要使用 Java 序列化： 想把的内存中的对象状态保存到一个文件中或者数据库中时候 想用套接字在网络上传送对象的时候 想通过 RMI（远程方法调用）传输对象的时候 59. 动态代理是什么？有哪些应用？动态代理是运行时动态生成代理类动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java 注解对象获取等 60. 怎么实现动态代理？JDK 原生动态代理和 cglib 动态代理JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的 对象拷贝61. 为什么要使用克隆？克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了 62. 如何实现对象克隆？ 实现 Cloneable 接口并重写 Object 类中的 clone() 方法 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆 63. 深拷贝和浅拷贝区别是什么？ 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制 Java Web64. JSP 和 servlet 有什么区别？JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑 65. JSP 有哪些内置对象？作用分别是什么？JSP 有 9 大内置对象： request：封装客户端的请求，其中包含来自 get 或 post 请求的参数 response：封装服务器对客户端的响应 pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象 application：封装服务器运行环境的对象 out：输出服务器响应的输出流对象 config：Web 应用的配置对象 page：JSP 页面本身(相当于 Java 程序中的 this) exception：封装页面抛出异常的对象 66. JSP 的 4 种作用域？ page：代表与一个页面相关的对象和属性 request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域 session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中 application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域 67. session 和 cookie 有什么区别？ session cookie 存储位置 服务器端 浏览器端 安全性 一般，可被伪造和修改 容量和个数限制 有容量限制和个数限制 存储的多样性 Redis 、数据库、应用程序等 只能存储在浏览器 68. session 的工作原理？session 的工作原理是客户端登录完成之后，服务器会创建对应的 sessionsession 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中这样客户端每次访问服务器时，都会带着 sessionid服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了 69. 如果客户端禁止 cookie 能实现 session 还能用吗？可以用session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用 70. springMVC 和 struts 的区别是什么？ springMVC struts 拦截级别 方法级别的拦截 类级别的拦截 数据独立性 方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量 方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦 拦截机制 独立的 aop 方式 nterceptor 机制 拦截机制 集成了 ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现 一般需要安装插件或者自己写代码才行 71. 如何避免 SQL 注入？ 使用预处理 PreparedStatement 使用正则表达式过滤掉字符中的特殊字符 72. 什么是 XSS 攻击，如何避免？XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞原理是攻击者往 Web 页面里插入恶意的脚本代码(css 代码、Javascript 代码等)，当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等预防 XSS 的核心是必须对输入的数据做过滤处理 73. 什么是 CSRF 攻击，如何避免？CSRF：Cross-Site Request Forgery(中文：跨站请求伪造)，可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等 防御手段： 验证请求来源地址 关键操作添加验证码 在请求地址添加 token 并验证 异常74. throw 和 throws 的区别？ throw：是真实抛出一个异常 throws：是声明可能会抛出一个异常 75. final、finally、finalize 有什么区别？ final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能再被改变，只能使用 finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码 finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法 76. try-catch-finally 中哪个部分可以省略？try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally 77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行 78. 常见的异常类有哪些？ NullPointerException 空指针异常 ClassNotFoundException 指定类不存在 NumberFormatException 字符串转换为数字异常 IndexOutOfBoundsException 数组下标越界异常 ClassCastException 数据类型转换异常 FileNotFoundException 文件未找到异常 NoSuchMethodException 方法不存在异常 IOException IO 异常 SocketException Socket 异常 网络79. http 响应码 301 和 302 代表的是什么？有什么区别？301：永久重定向302：暂时重定向它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险 80. forward 和 redirect 的区别？forward 是转发 和 redirect 是重定向： 地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变 数据共享：forward 可以共享 request 里的数据，redirect 不能共享 效率：forward 比 redirect 效率高 81. 简述 tcp 和 udp 的区别？tcp 和 udp 是 OSI 模型中的运输层中的协议tcp 提供可靠的通信传输udp 则常被用于让广播和细节控制交给应用的通信传输 两者的区别大致如下： tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接 tcp 提供可靠的服务（数据传输），udp 无法保证 tcp 面向字节流，udp 面向报文 tcp 数据传输慢，udp 数据传输快 82. tcp 为什么要三次握手，两次不行吗？为什么？如果采用两次握手，那么只要服务器发出确认数据包就会建立连接但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源 83. 说一下 tcp 粘包是怎么产生的？tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因： 发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收 84. OSI 的七层模型都有哪些？ 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输 数据链路层：负责建立和管理节点间的链路 网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径 传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输 会话层：向两个实体的表示层提供建立和使用连接的方法 表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等 应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作 85. get 和 post 请求有哪些区别？ get 请求会被浏览器主动缓存，而 post 不会 get 传递参数有大小限制，而 post 没有 post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会 post 产生２个 TCP 数据包，get 产生１个 TCP 数据包 86. 如何实现跨域？实现跨域有以下几种方案： 服务器端运行跨域 设置 CORS 等于 * 在单个接口使用注解 @CrossOrigin 运行跨域； 使用 jsonp 跨域 87. 说一下 JSONP 实现原理？jsonp：JSON with Padding，它是利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的 设计模式88. 你熟悉的设计模式？ 单例模式：保证被创建一次，节省系统开销 工厂模式（简单工厂、抽象工厂）：解耦代码 观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新 外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用 模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类 89. 简单工厂和抽象工厂有什么区别？ 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
        <tag>JAVA容器</tag>
        <tag>多线程</tag>
        <tag>反射</tag>
        <tag>对象拷贝</tag>
        <tag>JAVA Web</tag>
        <tag>异常</tag>
        <tag>网络</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F3265658309.html</url>
    <content type="text"><![CDATA[堆排序 堆排序运用的是二叉堆的特性。将无序数组构建成二叉堆，需要从小到大排序，则构建成最大堆 ，需要从大到小排序，则构建成最小堆。循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。 JAVA 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.xulin;import java.util.Arrays;/** * @ClassName HeapSort * @Description 堆排序 * @Author xulin * @Date 2019/7/1 */public class HeapSort &#123; /** * @Description: 下沉调整 * @Param: [array, parentIndex, length] 待调整的堆；要下沉的父节点；堆的有效大小 * @return: void * @Author: xulin * @Date: 2019/7/1 */ public static void downAdjust(int[] array,int parentIndex,int length)&#123; //temp保存父节点值，用于最后的赋值 int temp=array[parentIndex]; int childIndex=2*parentIndex+1; while (childIndex&lt;length)&#123; //如果有右孩子，且右孩子的值大于左孩子的值，则定位到右孩子 if (childIndex+1&lt;length &amp;&amp; array[childIndex+1]&gt;array[childIndex])&#123; childIndex++; &#125; //如果父节点大于等于任何一个孩子的值，直接跳出 if (temp&gt;=array[childIndex])&#123; break; &#125; //无需真正交换，单向赋值即可 array[parentIndex]=array[childIndex]; parentIndex=childIndex; childIndex=2*childIndex+1; &#125; array[parentIndex]=temp; &#125; /** * @Description: 堆排序（什序） * @Param: [array] 待调整的堆 * @return: void * @Author: xulin * @Date: 2019/7/1 */ public static void heapSort(int[] array)&#123; //1.把无序数组构建成最大堆 for (int i=(array.length-2)/2;i&gt;=0;i--)&#123; downAdjust(array,i,array.length); &#125; System.out.println(Arrays.toString(array)); //2.循环交换集合尾部元素到堆顶，并调节堆产生新的堆顶 for (int i=array.length-1;i&gt;0;i--)&#123; //最后一个元素和第一元素进行交换 int temp=array[i]; array[i]=array[0]; array[0]=temp; //下沉调整最大堆 downAdjust(array,0,i); &#125; &#125; public static void main(String[] args) &#123; int[] array=new int[]&#123;1,4,3,2,7,5,6,8,9&#125;; heapSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 其它时间复杂度：O(nlogn)。不稳定排序。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F4286605504.html</url>
    <content type="text"><![CDATA[快速排序 快速排序和冒泡排序一样属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。快速排序在每一轮挑选一个基准元素，并让其它比它大的元素移动在数列一边，比它小的元素移到数列的另一边，从而把数列拆解成两个部分。 大概步骤基准元素：pivot。mark 指针：小于基准元素的区域边界。从基准元素的下一个位置开始遍历数组。如果遍历到的元素大于基准元素，继续往后遍历。 如果遍历到的元素小于基准元素: mark 指针右移 1 位。 最新遍历到的元素和 mark 指针所在位置的元素交换位置。 JAVA 代码实现(分治)单边循环法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.xulin;import java.util.Arrays;/** * @ClassName QuickSort * @Description 快速排序（单边循环法） * @Author xulin * @Date 2019/6/30 */public class QuickSort &#123; /** * @Description: 快速排序 * @Param: [arr, startIndex, endIndex] 待交换的数组；起始下标；结束下标 * @return: void * @Author: xulin * @Date: 2019/6/30 */ public static void quickSort(int[] arr,int startIndex,int endIndex)&#123; //递归结束条件：startIndex&gt;=endIndex的时候 if (startIndex&gt;=endIndex)&#123; return; &#125; //得到基准元素位置 int pivotIndex=partition(arr,startIndex,endIndex); //根据基准元素，分成两部分递归排序 quickSort(arr,startIndex,pivotIndex-1); quickSort(arr,pivotIndex+1,endIndex); &#125; /** * @Description: 分治（单边循环法） * @Param: [arr, startIndex, endIndex] 待交换的数组；起始下标；结束下标 * @return: int * @Author: xulin * @Date: 2019/6/30 */ private static int partition(int[] arr,int startIndex,int endIndex)&#123; //取第一个位置的元素作为基准元素（也可以选择随机位置） int pivot=arr[startIndex]; int mark=startIndex; for (int i=startIndex+1;i&lt;=endIndex;i++)&#123; if (arr[i]&lt;pivot)&#123; mark++; int p=arr[mark]; arr[mark]=arr[i]; arr[i]=p; &#125; &#125; arr[startIndex]=arr[mark]; arr[mark]=pivot; return mark; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;4,4,6,5,3,2,8,1&#125;; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125; 其他时间复杂度：O(nlogn) 最坏情况：O(n^2)。不稳定排序。 重点基准元素的选择，元素的交换。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F350679531.html</url>
    <content type="text"><![CDATA[冒泡排序 冒泡排序：将相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。 优化优化１：判断出数列已经有序，做出标记，剩下的几轮排序不必执行。优化２：记录元素最后交换的位置，该位置为无序数列的边界，后面就是有序区。 JAVA 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xulin;import java.util.Arrays;/** * @ClassName BubbleSort * @Description 优化的冒泡排序 * @Author xulin * @Date 2019/6/29 */public class BubbleSort &#123; private static void sort(int array[])&#123; int temp=0; //记录最后一次交换的位置 int lastExchangeIndex=0; //无序数列的边界，每次比较只需要比到这里 int sortBorder=array.length-1; for (int i=0;i&lt;array.length;i++)&#123; //有序标记，每一轮的初始都是true boolean isSorted=true; for (int j=0;j&lt;sortBorder;j++)&#123; if (array[j]&gt;array[j+1])&#123; temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; //有元素交换，所以不是有序，标记变为false isSorted=false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangeIndex=j; &#125; &#125; sortBorder=lastExchangeIndex; if (isSorted)&#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array=new int[]&#123;4,6,1,3,7,4,9,5&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 其他时间复杂度：O(n^2)。 稳定排序，值相等的元素不会打乱原来的顺序。 鸡尾酒排序鸡尾酒排序的元素比较和交换过程都是双向的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F1613684904.html</url>
    <content type="text"><![CDATA[优先队列不再遵循先进先出的原则，分 2 种情况。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队。 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队。 线性数据结构实现二叉堆的时间复杂度较高，所以用二叉堆实现优先队列。 JAVA 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.xulin;import java.util.Arrays;/** * @ClassName PriorityQueue * @Description 优先队列 * @Author xulin * @Date 2019/6/28 */public class PriorityQueue &#123; private int[] array; private int size; public PriorityQueue()&#123; //队列初始长度３２ array=new int[32]; &#125; /** * @Description: 入队 * @Param: [key] 入队元素 * @return: void * @Author: xulin * @Date: 2019/6/28 */ public void enQueue(int key)&#123; //队列长度超出范围，扩容 if (size&gt;=array.length)&#123; resize(); &#125; array[size++]=key; upAdjust(); &#125; public int deQueue()throws Exception&#123; if (size&lt;=0)&#123; throw new Exception("队空!\n"); &#125; //获取堆顶元素 int head=array[0]; //最后一个元素移动到堆顶 array[0]=array[--size]; downAdjust(); return head; &#125; /** * @Description: 上浮调整 * @Param: [] * @return: void * @Author: xulin * @Date: 2019/6/27 */ private void upAdjust()&#123; int childIndex=size-1; int parentIndex=(childIndex-1)/2; //temp保存插入的叶子节点值，用于最后的赋值 int temp=array[childIndex]; while (childIndex&gt;0 &amp;&amp; temp&gt;array[parentIndex])&#123; //无需真正交换，单向赋值即可 array[childIndex]=array[parentIndex]; childIndex=parentIndex; parentIndex=parentIndex/2; &#125; array[childIndex]=temp; &#125; /** * @Description: 下沉调整 * @Param: [] * @return: void * @Author: xulin * @Date: 2019/6/27 */ private void downAdjust()&#123; int parentIndex=0; //temp保存父节点值，用于最后赋值 int temp=array[parentIndex]; int childIndex=1; while (childIndex&lt;size)&#123; //如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子 if (childIndex+1&lt;size &amp;&amp; array[childIndex+1]&gt;array[childIndex])&#123; childIndex++; &#125; //如果父节点小于任何一个孩子的值，直接跳出 if (temp&gt;=array[childIndex])&#123; break; &#125; //无需进行真正交换，单向赋值即可 array[parentIndex]=array[childIndex]; parentIndex=childIndex; childIndex=2*childIndex+1; &#125; array[parentIndex]=temp; &#125; /** * @Description: 队列扩容 * @Param: [] * @return: void * @Author: xulin * @Date: 2019/6/28 */ private void resize()&#123; //队列容量翻倍 int newSize=this.size*2; this.array= Arrays.copyOf(this.array,newSize); &#125; public static void main(String[] args) throws Exception&#123; PriorityQueue priorityQueue=new PriorityQueue(); priorityQueue.enQueue(3); priorityQueue.enQueue(5); priorityQueue.enQueue(10); priorityQueue.enQueue(2); priorityQueue.enQueue(7); System.out.println("出队元素:"+priorityQueue.deQueue()); System.out.println("出队元素:"+priorityQueue.deQueue()); &#125;&#125; 其他优先队列的时间复杂度都是O(logn)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉堆]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E5%A0%86%2F1774736084.html</url>
    <content type="text"><![CDATA[最小堆 二叉堆本质上是一种完全二叉树，分2个类型。 最大堆 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。 最小堆 最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。 二插堆的根节点叫堆顶，最大堆的堆顶是整个堆中的最大元素，最小堆的堆顶是整个堆中的最小元素。 二叉堆的自我调整 插入节点。 删除节点。 构建二叉堆。 1.插入节点以最小堆为例当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。若父节点比插入的节点大，则不断上浮调整。 时间复杂度为O(logn)。 2.删除节点以最小堆为例二叉堆删除节点的过程和插入节点的过程相反，删除的是处于堆顶的节点。将堆的最后一个节点补充到删除的节点，不断进行下沉调整。 时间复杂度为O(logn)。 3.构建二叉堆构建二叉堆，就是把一个无序的完全二叉树调整为二叉堆。本质就是让所有非叶子节点依次下沉。 JAVA 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.xulin;import java.util.Arrays;/** * @ClassName HeapOperator * @Description 二叉堆(最小堆) * @Author xulin * @Date 2019/6/27 */public class HeapOperator &#123; /** * @Description: 上浮调整 * @Param: [array] 待调整的堆 * @return: void * @Author: xulin * @Date: 2019/6/27 */ public static void upAdjust(int[] array)&#123; int childIndex=array.length-1; int parentIndex=(childIndex-1)/2; //temp保存插入的叶子节点值，用于最后的赋值 int temp=array[childIndex]; while (childIndex&gt;0 &amp;&amp; temp&lt;array[parentIndex])&#123; //无需真正交换，单向赋值即可 array[childIndex]=array[parentIndex]; childIndex=parentIndex; parentIndex=(parentIndex-1)/2; &#125; array[childIndex]=temp; &#125; /** * @Description: 下沉调整 * @Param: [array, parentIndex, length] 待调整的堆；要下沉的父节点；堆的有效大小 * @return: void * @Author: xulin * @Date: 2019/6/27 */ public static void downAdjust(int[] array,int parentIndex,int length)&#123; //temp保存父节点值，用于最后赋值 int temp=array[parentIndex]; int childIndex=2*parentIndex+1; while (childIndex&lt;length)&#123; //如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子 if (childIndex+1&lt;length &amp;&amp; array[childIndex+1]&lt;array[childIndex])&#123; childIndex++; &#125; //如果父节点小于任何一个孩子的值，直接跳出 if (temp&lt;=array[childIndex])&#123; break; &#125; //无需进行真正交换，单向赋值即可 array[parentIndex]=array[childIndex]; parentIndex=childIndex; childIndex=2*childIndex+1; &#125; array[parentIndex]=temp; &#125; /** * @Description: 构建堆 * @Param: [array] 待调整的堆 * @return: void * @Author: xulin * @Date: 2019/6/27 */ public static void buildHeap(int[] array)&#123; //从最后一个非叶子节点开始，依次进行调整 for (int i=(array.length-2)/2;i&gt;=0;i--)&#123; downAdjust(array,i,array.length); &#125; &#125; public static void main(String[] args) &#123; int[] array=new int[]&#123;1,3,2,6,5,7,8,9,10,0&#125;; upAdjust(array); System.out.println(Arrays.toString(array)); array=new int[] &#123;7,1,3,10,5,2,8,9,6&#125;; buildHeap(array); System.out.println(Arrays.toString(array)); &#125;&#125; 其他二叉堆是实现堆排序和优先队列的基础。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F%E6%A0%91%2F2065787451.html</url>
    <content type="text"><![CDATA[二分搜索树 树是n(n&gt;=0)个节点的有限集，当n＝０时，称为空树。 特点： 有且只有一个特定的称为根的节点。 当 n&gt;1 时，其余节点可分为 m(m&gt;0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 二叉树(binary tree)每个节点最多有 2 个孩子节点。 二叉树节点的两个孩子节点，一个称为左孩子，一个被称为右孩子。 链式存储结构 存储数据的 data 变量。 指向左孩子的 left 指针。 指向右孩子的 right 指针。 数组 按照层级顺序把二叉树的节点放到数组中对应的位置 。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。 父节点下标是parent，左孩子节点下标为2parent+1*，*右孩子节点下标为2parent+2_。_ 1.满二叉树一个二叉树所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级，满二叉树的每一个分支都是满的。 2.完全二叉树对一个有n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。这个树所有节点和同样深度的满二叉树的编号从 1 到 n 的节点位置相同。 二叉堆是一种特殊的完全二叉树，用数组存储。 3.应用 查找操作。 维持相对顺序。 ① 查找二叉树的树形结构使它很适合扮演索引的角色。 二叉查找树 如果左子树不为空，则左子树上所有节点的值均小于根节点的值。 如果右子树不为空，则右子树上所有节点的值均大于根节点的值。 左、右子树也都是二叉查找树。 对于一个节点分布相对均衡的二叉查找树，如果节点总数是 n。搜索节点的时间复杂度就是 O(logn)，和树的深度一样。 ② 维持相对顺序二叉查找树也叫二叉排序树。二叉树自平衡的方式有很多种，如红黑树、AVL 树、树堆等。 4.遍历 深度优先遍历(前序遍历，中序遍历，后序遍历)。 广度优先遍历(层序遍历)。 ① 深度优先遍历 前序的第一个是整个树的根。后序的最后一个是整个树的根。中序用来判别左右子树的划分。前序序列中左子树部分的第一个节点是左子树的根节点。 前序序列中右子树部分的第一个节点是右子树的根节点。 JAVA 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.xulin;import java.util.Arrays;import java.util.LinkedList;/** * @ClassName BinaryTreeTraversal * @Description 二叉树 * @Author xulin * @Date 2019/6/25 */public class BinaryTreeTraversal &#123; /** * @Description: 构建二叉树 * @Param: [inputList] 输入序列 * @return: com.xulin.BinaryTreeTraversal.TreeNode * @Author: xulin * @Date: 2019/6/25 */ public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList)&#123; TreeNode node=null; if (inputList==null || inputList.isEmpty())&#123; return null; &#125; Integer data=inputList.removeFirst(); if (data!=null)&#123; node=new TreeNode(data); node.leftChild=createBinaryTree(inputList); node.rightChild=createBinaryTree(inputList); &#125; return node; &#125; /** * @Description: 二叉树前序遍历 * @Param: [node] 二叉树节点 * @return: void * @Author: xulin * @Date: 2019/6/25 */ public static void preOrderTraversal(TreeNode node)&#123; if (node==null)&#123; return; &#125; System.out.println(node.data); preOrderTraversal(node.leftChild); preOrderTraversal(node.rightChild); &#125; /** * @Description: 二叉树中序遍历 * @Param: [node] 二叉树节点 * @return: void * @Author: xulin * @Date: 2019/6/25 */ public static void inOrderTraversal(TreeNode node)&#123; if (node==null)&#123; return; &#125; inOrderTraversal(node.leftChild); System.out.println(node.data); inOrderTraversal(node.rightChild); &#125; /** * @Description: 二叉树后序遍历 * @Param: [node] 二叉树节点 * @return: void * @Author: xulin * @Date: 2019/6/25 */ public static void postOrderTraversal(TreeNode node)&#123; if (node==null)&#123; return; &#125; postOrderTraversal(node.leftChild); postOrderTraversal(node.rightChild); System.out.println(node.data); &#125; /** * @Description: 二叉树节点 * @Param: * @return: * @Author: xulin * @Date: 2019/6/25 */ private static class TreeNode&#123; int data; TreeNode leftChild; TreeNode rightChild; TreeNode(int data)&#123; this.data=data; &#125; &#125; /** * @Description: 二叉树遍历测试代码 * @Param: [args] * @return: void * @Author: xulin * @Date: 2019/6/25 */ public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; inputList=new LinkedList&lt;Integer&gt;( Arrays.asList(new Integer[]&#123;3,2,9,null,null,10,null,null,8,null,4&#125;) ); TreeNode treeNode=createBinaryTree(inputList); System.out.println("前序遍历:"); preOrderTraversal(treeNode); System.out.println("中序遍历:"); inOrderTraversal(treeNode); System.out.println("后序遍历:"); postOrderTraversal(treeNode); &#125;&#125; 前序遍历输出顺序：根节点、左子树、右子树。 Java 代码 123456789public static void preOrderTraversal(TreeNode node)&#123; if(node==null)&#123; return; &#125; System.out.println(node.data); preOrderTraversal(node.leftChild); preOrderTraversal(node.rightChild);&#125; 中序遍历输出顺序：左子树、根节点、右子树。 Java 代码 123456789public static void inOrderTraversal(TreeNode node)&#123; if(node==null)&#123; return; &#125; inOrderTraversal(node.leftChild); System.out.println(node.data); inOrderTraversal(node.rightChild);&#125; 后序遍历输出顺序：左子树、右子树、根节点。 Java 代码 123456789public static void postOrderTraversal(TreeNode node)&#123; if(node==null)&#123; return; &#125; postOrderTraversal(node.leftChild); postOrderTraversal(node.rightChild); System.out.println(node.data);&#125; ② 广度优先遍历层序遍历二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。 Java 代码 12345678910111213141516public static void levelOrderTraversal(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty())&#123; TreeNode node=queue.poll(); System.out.println(node.data); if (node.leftChild!=null)&#123; queue.offer(node.leftChild); &#125; if (node.rightChild!=null)&#123; queue.offer(node.rightChild); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F2232361088.html</url>
    <content type="text"><![CDATA[在 Java 中，每一个对象都有属于自己的hashcode。无论对象自身的类型是什么，他们的 hashcode 都是一个整型变量。 哈希函数通过某种方式(中转站)，把 Key 和数组下标进行转换，这个中转站就是哈希函数。整型变量装换为数组下标，最简单的方式是按照数组长度进行取模运算。 index=HashCode(Key)%Array.length JDK1.8 中的哈希函数没有直接采用取模运算，而是利用了位运算的方式来优化性能。 哈希表的读写操作1.写操作(put)写操作就是在哈希表中插入新的键值对(Entry)。 通过哈希函数，将 Key 转化为数组下标。 如果转化的数组下标对应的数组位置没有元素，就把这个 Entry 填充到转化的数组下标的位置。 ① 哈希冲突由于数组的长度有限，当插入的 Entry 越来越多，不同的 Key 通过哈希函数获得的下标有可能是相同的这种情况，叫做哈希冲突。**解决哈希冲突的方法主要有 2 种。 开放寻址法。 链表法。 ② 开放寻址法在 Java 中，ThreadLocal 所使用的就是开放寻址法。当一个 Key 通过哈希函数获得对应的数组下标已被占用时，可以寻找下一个空挡位置如后移一位，寻址方式有很多，并不一定只是简单地寻找当前元素的后一个元素。 ③ 链表法在 Java 中，HashMap 使用的是链表法。HashMap 数组的每一个元素不仅是一个 Entry 对象，还是一个链表的头节点。每一个 Entry 对象通过 next 指针指向它的下一个 Entry 对象，当新来的 Entry 映射到与之冲突的数组位置时，只需插入到对应的链表中。 2.读操作(get)读操作就是通过给定的 Key，在哈希表中查找对应的 Value。 通过哈希函数，将 Key 转化为数组下标。 找到转化的数组下标所对应的元素，如果和待查找的 Key 不符，可顺着链表往下找。 3.扩容(resize)当经过多次元素插入，哈希表达到一定的饱和时，Key 映射位置发生冲突的概率会逐渐提高。大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入和查询的性能有很大影响。这时，哈希表需要扩展它的长度，就是进行扩容。 影响扩容的因素有２个。 1.Capacity，HashMap 的当前长度,。2.LoadFactor，HashMap 的负载因子，默认值为 0.75f。 衡量 HashMap 需要扩容的条件如下： HashMap.Size&gt;=CapacityLoadFactor 操作 扩容，创建一个新的 Entry 空数组，长度是原数组的 2 倍。 重新 Hash，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组。长度扩大后，Hash 的规则也随之改变。经过扩容，原本拥挤的哈希表重新变得稀疏，原来的 Entry 也重新得到了尽可能均匀的分配。 其他当多个 Entry 被 Hash 到同一个数组下标位置时，为了提升插入和查找的效率，HashMap 会把 Entry 的链表转化为红黑树这种数据结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环队列]]></title>
    <url>%2F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%2F3060233409.html</url>
    <content type="text"><![CDATA[队列是一种线性数据结构，队列中的元素只能先进先出(FIFO)。队列的出口端叫做队头，队列的入口端叫做队尾。 基本操作1.入队将新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。 2.出队将元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将为成为新的队头。 循环队列重点（队尾下标+1）%数组长度=队头下标，队列已满。 时间复杂度入队和出队的时间复杂度都是 O(1)。 JAVA 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.xulin;/** * @ClassName MyQueue * @Description 循环队列的实现 * @Author xulin * @Date 2019/6/24 */public class MyQueue &#123; private int[] array; //队列长度 private int front; //队头 private int rear; //队尾 /** * @Description: 初始化队列长度 * @Param: [capacity] * @return: * @Author: xulin * @Date: 2019/6/24 */ public MyQueue(int capacity)&#123; this.array=new int[capacity]; &#125; /** * @Description: 入队 * @Param: [element] * @return: void * @Author: xulin * @Date: 2019/6/24 */ public void enQueue(int element) throws Exception &#123; //（队尾下标+1）%数组长度=队头下标，队列已满 if ((rear+1)%array.length==front)&#123; throw new Exception("队列已满!\n"); &#125; array[rear]=element; rear=(rear+1)%array.length; &#125; /** * @Description: 出队 * @Param: [] * @return: int * @Author: xulin * @Date: 2019/6/24 */ public int deQueue()throws Exception&#123; if (rear==front)&#123; throw new Exception("队列已空!\n"); &#125; int deQueueElement=array[front]; front=(front+1)%array.length; return deQueueElement; &#125; /** * @Description: 输出队列 * @Param: [] * @return: void * @Author: xulin * @Date: 2019/6/24 */ public void output()&#123; for (int i=front;i!=rear;i=(i+1)%array.length)&#123; System.out.println(array[i]); &#125; &#125; /** * @Description: 测试队列 * @Param: [args] * @return: void * @Author: xulin * @Date: 2019/6/24 */ public static void main(String[] args) throws Exception&#123; MyQueue myQueue=new MyQueue(6); myQueue.enQueue(3); myQueue.enQueue(5); myQueue.enQueue(6); myQueue.enQueue(8); myQueue.enQueue(1); myQueue.deQueue(); myQueue.deQueue(); myQueue.enQueue(2); myQueue.enQueue(4); myQueue.output(); &#125;&#125; 应用队列的输出顺序和输入顺序相同，队列通常用于对“历史”的回放。 例： 多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序。 网络爬虫，将待抓取的网站URL存入队列，再按照存入的顺序依次进行抓取和解析。 其他1.双端队列结合了栈和队列的优点，从队头和队尾皆可入队或出队。 2.优先队列谁的优先级高，谁先出队，基于二叉堆实现。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现栈]]></title>
    <url>%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%2F634881399.html</url>
    <content type="text"><![CDATA[出、入栈顺序 gif 图 栈栈是一种线性数据结构，栈中的元素只能先进后出(FILO)，最先进入的元素存放的位置叫栈底，最后进入的元素存放的位置叫栈顶。 基本操作1.入栈(push)把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。 2.出栈(pop)把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。 JAVA 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.xulin;/** * @ClassName MyLinkStack * @Description 链表实现栈 * @Author xulin * @Date 2019/6/22 */public class MyLinkStack &#123; private Node top; //栈顶元素 private int size=0; //栈的大小 public MyLinkStack()&#123; top=null; &#125; class Node&#123; public int data; //数据 public Node next; Node(int data)&#123; this.data=data; &#125; &#125; /** * @Description: 入栈 * @Param: [data] * @return: void * @Author: xulin * @Date: 2019/6/22 */ public void push(int data)&#123; Node newNode=new Node(data); if (top==null)&#123; top=newNode; &#125;else&#123; newNode.next=top; top=newNode; &#125; size++; &#125; /** * @Description: 出栈 * @Param: [] * @return: java.lang.Integer * @Author: xulin * @Date: 2019/6/22 */ public Integer pop()&#123; if (top==null)&#123; throw new RuntimeException("栈为空!\n"); &#125;else&#123; int temp=top.data; top=top.next; size--; return temp; &#125; &#125; /** * @Description: 查看栈顶元素 * @Param: [] * @return: java.lang.Integer * @Author: xulin * @Date: 2019/6/22 */ public Integer getTop()&#123; if (top==null)&#123; throw new RuntimeException("栈为空!\n"); &#125;else &#123; return top.data; &#125; &#125; /** * @Description: 返回栈的大小 * @Param: [] * @return: int * @Author: xulin * @Date: 2019/6/22 */ public int getSize()&#123; return size; &#125; public static void main(String[] args) &#123; MyLinkStack myLinkStack=new MyLinkStack(); myLinkStack.push(2); myLinkStack.push(1); myLinkStack.push(3); myLinkStack.push(5); System.out.println(myLinkStack.getTop()); System.out.println(myLinkStack.getSize()); &#125;&#125; 应用栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯 例： 实现递归的逻辑，用栈来代替 面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面 其他入栈和出栈的时间复杂度都是 O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F%E9%93%BE%E8%A1%A8%2F593668330.html</url>
    <content type="text"><![CDATA[链表是一种在物理上非连续、非顺序的数据结构，由若干节点组成。可以想象成火车，一节一节的连接在一起。 基本操作1.更新节点直接把旧数据换成新数据 2.插入节点① 尾部插入将最后一个节点的 next 指针指向新插入的节点 12345else if(size==index)&#123; //插入尾部 last.next=insertNode; last=insertNode; &#125; ② 头部插入 将新节点的 next 指针指向原先的头节点 将新节点变为链表的头节点 1234if(index==0)&#123; insertNode.next=head; head=insertNode;&#125; ③ 中间插入 将插入位置的前置节点的 next 指针指向新插入的新节点 将新节点的 next 指针指向前置节点的 next 指针原先指向的节点 12345else&#123; Node prevNode=get(index-1); insertNode.next=prevNode.next; prevNode.next=insertNode;&#125; 3.删除节点① 尾部删除将倒数第 2 个节点的 next 指针指向空即可 123456else if(index==size)&#123; Node prevNode=get(index-1); removeNode=prevNode.next; prevNode.next=null; last=prevNode;&#125; ② 头部删除将链表的头节点设为原先头节点的 next 指针 1234if(index==0)&#123; removeNode=head; head=head.next;&#125; ③ 中间删除将要删除节点的前置节点的 next 指针,指向要删除元素的下一个节点 123456else&#123; Node prevNode=get(index-1); Node nextNode=prevNode.next.next; removeNode=prevNode.next; prevNode.next=nextNode;&#125; 4.时间复杂度不考虑插入、删除操作之前查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是 O(1) JAVA 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.xulin;/** * @ClassName MyLinkedList * @Description 链表 * @Author xulin * @Date 2019/6/22 */public class MyLinkedList &#123; private Node head; //头节点指针 private Node last; //尾节点指针 private int size; //链表实际长度 /** * @Description: 链表插入元素 * @Param: [data, index] * @return: void * @Author: xulin * @Date: 2019/6/22 */ public void insert(int data,int index)&#123; if (index&lt;0 || index&gt;size)&#123; throw new IndexOutOfBoundsException("超出链表节点范围!\n"); &#125; Node insertNode=new Node(data); if (size==0)&#123; //空链表 head=insertNode; last=insertNode; &#125;else if (index==0)&#123; //插入头部 insertNode.next=head; head=insertNode; &#125;else if (size==index)&#123; //插入尾部 last.next=insertNode; last=insertNode; &#125;else&#123; //插入中间 Node prevNode=get(index-1); insertNode.next=prevNode.next; prevNode.next=insertNode; &#125; size++; &#125; /** * @Description: 链表删除元素 * @Param: [index] * @return: com.xulin.MyLinkedList.Node * @Author: xulin * @Date: 2019/6/22 */ public Node remove(int index)&#123; if (index&lt;0 || index&gt;size)&#123; throw new IndexOutOfBoundsException("超出链表节点范围!\n"); &#125; Node removeNode=null; if (index==0)&#123; //删除头节点 removeNode=head; head=head.next; &#125;else if (index==size-1)&#123; //删除尾节点 Node prevNode=get(index-1); removeNode=prevNode.next; prevNode.next=null; last=prevNode; &#125;else&#123; //删除中间节点 Node prevNode=get(index-1); Node nextNode=prevNode.next.next; removeNode=prevNode.next; prevNode.next=nextNode; &#125; size--; return removeNode; &#125; /** * @Description: 链表查找元素 * @Param: [index] * @return: com.xulin.MyLinkedList.Node * @Author: xulin * @Date: 2019/6/22 */ public Node get(int index)&#123; if (index&lt;0 || index&gt;size)&#123; throw new IndexOutOfBoundsException("超出链表节点范围!\n"); &#125; Node temp=head; for (int i=0;i&lt;index;i++)&#123; temp=temp.next; &#125; return temp; &#125; /** * @Description: 输出链表 * @Param: [] * @return: void * @Author: xulin * @Date: 2019/6/22 */ public void output()&#123; Node temp=head; while (temp!=null)&#123; System.out.println(temp.data); temp=temp.next; &#125; &#125; /** * @Description: 链表节点 * @Param: * @return: * @Author: xulin * @Date: 2019/6/22 */ private static class Node&#123; int data; Node next; Node(int data)&#123; this.data=data; &#125; &#125; /** * @Description: 测试 * @Param: [args] * @return: void * @Author: xulin * @Date: 2019/6/23 */ public static void main(String[] args) &#123; MyLinkedList myLinkedList=new MyLinkedList(); myLinkedList.insert(3,0); myLinkedList.insert(4,0); myLinkedList.insert(9,2); myLinkedList.insert(5,3); myLinkedList.remove(0); myLinkedList.output(); &#125;&#125; 其他 数组 链表 查找 O(1) O(n) 更新 O(1) O(1) 插入 O(n) O(1) 删除 O(n) O(1) 总结 快速定位元素，适合读操作多，写操作少的情景。 灵活进行插入和删除操作，适合尾部频繁插入、删除元素的情景。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语雀+TravisCI+Serverless]]></title>
    <url>%2F%E8%AF%AD%E9%9B%80%2BTravisCI%2BServerless%2F3689364350.html</url>
    <content type="text"><![CDATA[技术介绍语雀语雀是阿里巴巴旗下的专业云端知识库，支持Markdown语法，个人和团队皆可用于文档编写。它不仅仅是一个在线编写文档的工具，还集成了Web Hook ，为自动化部署 Hexo 建立了基础。 而yuque-hexo是x-cold根据语雀的 API 为 Hexo 博客写的插件，可以很方便的将语雀指定知识库里的文章全部更新到 hexo 博客中。 Travis CITravis CI可以很方便地将GitHub的项目持续集成并构建。 ServerlessServerless可以通过代码唤起 Travis CI 执行构建项目。 自动部署流程图自动部署总体流程如下。为了更容易理解，我给流程图配了 logo（可能只是更好看）。 我先一步步解释，千万不要被流程图的专业术语唬住。实线框的是可以感知到的实体，虚线框的一般不可感知，但要进行配置。 简略的流程解释如下： 首先通过语雀写好博客，点击保存/更新，触发语雀设置的 Web Hook。 Web Hook 触发在腾讯云的 Serverless 函数。 Serverless 函数发起一个请求，触发 Travis CI 构建。 Travis CI 执行完毕后，将构建的产物 push 到指定代码仓库，部署博客。 Travis CI因为 Travis CI 是本次成功的关键，同时也由于它算是最难的一个技术点，所以我先来详细解释。 Travis CI 只支持构建 github 的项目，所以必须把博客源码push 到 github。而 Travis CI 如何获取博客源码项目，由于过于简单，我就不说了。 其实配置 Travis CI 就是配置最主要的两个点，在博客源码根目录下编写 .travis.yml 文件和在 Travis CI 项目里设置Environment Variables(环境变量)。这个环境变量相当于将一些敏感信息隐藏，以变量代替。例如代码仓库的 Token 和代码仓库地址。 .travis.yml我的.travis.yml 配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 选择语言language: node_js# 选择语言版本node_js: - "v10.15.3"# 指定监视分支，若分支有变动，执行构建branches: only: - master# 构建结果通知，通过邮箱通知notifications: email: recipients: - aqpcet@foxmail.com on_success: always # default: change on_failure: always # default: alway# 指定缓存模块(可选)，缓存可加快构建速度。cache: directories: - node_modules# 设置时区before_install: - export TZ='Asia/Shanghai'# 安装hexo及各种插件，#号后为注释项install: # 安装全局gulp # - npm install --global gulp # 安装全局yuque-hexo # - npm install --global yuque-hexo # 安装 - npm install# 先清除语雀缓存，在同步语雀上的文章，最后通过gulp用于构建# 我有设置gulp的文件，所以可以直接使用gulp命令压缩和生成博客文件# 你也可以直接，hexo clean &amp; hexo g生成博客文件script: # clean语雀缓存 - yuque-hexo clean # pull语雀文章 - yuque-hexo sync # 生成静态文件 - gulp # 如果没有设置gulp，请注释上面命令 - hexo clean &amp; hexo g# 生成博客文件后，自然是将生成的博客文件push到指定的仓库进行部署# 其中的USER_NAME,USER_EMAIL,CD_TOKEN,CD_REF,GH_TOKEN,GH_REF# 是我在(vironment Variables)境变量配置的，具体配置位置往下看。after_script: - cd ./public - git init - git config user.name "$&#123;USER_NAME&#125;" - git config user.email "$&#123;USER_EMAIL&#125;" - git add . - git commit -m "Update Blog By TravisCI" # Coding Pages - git push --force --quiet "https://$&#123;USER_NAME&#125;:$&#123;CD_TOKEN&#125;@$&#123;CD_REF&#125;" master:master # Github Pages - git push --force --quiet "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:master 在上面的文件中，我的注释应该可以很好的明白.travis.yml 的配置，如果还是不清楚，可以通过邮箱跟我联系(切记勿急，仔细看)。 Environment Variables(环境变量)Travis CI 进入 Environment Variables(环境变量)如下图。 设置 Environment Variables(环境变量)如下图。 具体设置上图中已说明，就是设置环境变量，将敏感信息隐藏。 Travis CI 构建Travis CI 构建成功如下图。 注意 Travis-CI.com 和 Travis-CI.org 不一样(我用的是.com 的)。 环境变量的变量名要大写。 .travis.yml 文件是隐藏文件(名字以.开头)，要记住勾选显示隐藏文件。 环境变量的变量信息如单词所示，为 github 的 Token 和 pages 仓库地址，coding 的 Token 和 pages 仓库地址，username，email。 Serverless我使用的是腾讯云的 Serverless 服务。 首先进入腾讯云的 Serverless 服务，选择新建。具体的服务新建配置如下图。 填写好基础信息后，选择下一步，进入函数配置。函数配置如下图。 点击完成后，就可以看到函数配置。函数配置如下图。 点击函数代码，进行代码编写。函数代码如下图。 点击保存即可保存函数代码。函数代码其实就是向 Travic CI 发一个 POST 请求,当然你也可以使用 postman 来触发 Travis CI 构建，代码中需要填写相关的请求信息，其中的token如下图所示。 ropes为: github 用户名/博客源码仓库名称 点击触发方式，再点击新建触发方式。触发方式创建如下图。 新建触发方式的访问路径要复制下来，等一下配置Web Hook会用到。 运行日志中可以看到运行的成功与否。运行日志如下图。 语雀yuque-hexoyuque-hexo 这个插件的配置方式参考上面给出的插件 github 地址，如果遇到什么问题，先去 issue 上搜索看看有没有对应的解决方式。 Web Hookweb Hook 的具体设置如下图。 总结这样下来，以后写博客，直接在语雀上写好，然后点击保存就可以同步更新在个人博客上了。 这个教程有一些地方需要很仔细，我当时按照这个博客配置的时候，有一些不太明白的点，后面都解决了，感谢这位无私的博主，同时我在他的基础上更细化了配置的过程，添加了更多的配置图。 如果调用 Serverless 函数失败，不用着急，有可能是语雀的问题，重新打开或刷新语雀，然后保存/更新，一般可解决。或者是 Serverless 函数配置的时间过短，腾讯云还没反应。]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>yuque-hexo</tag>
        <tag>TravisCI</tag>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch下载文件]]></title>
    <url>%2FFetch%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F6637959.html</url>
    <content type="text"><![CDATA[Fetch 是什么 Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。这种功能以前是使用 XMLHttpRequest实现的。Fetch 提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。除此之外，Fetch 还利用到了请求的异步特性——它是基于Promise的。 作者：ceido链接：https://www.jianshu.com/p/1b966c113f64来源：简书 总而言之，它就像 ajax 一样。 前因之前做毕业设计的时候，需要导出 excel 数据表。于是后端写了个接口，主要就是将数据库的数据以文件流的方式导出。但是，由于使用的是基于 React.js 的 Ant Design Pro 的前端，而 Ant Design Pro 使用的正是 Fetch。 由于不太熟悉 Fetch 的用法，在网上遍寻了很久仍没有解决问题。经过我的不断尝试，终于解决，特此记录。 解决在 Ant Design Pro 的 server 中写的接口，如下图。 然后在 model 里使用 callback 方法，返回 blob 类型，如下图。 最后再写具体的下载方法，如下图。 调用方式，如下图。 总结总之就是调用后端接口时，要指定文件类型。还有就是多点尝试，可能就会豁然开朗。]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业？]]></title>
    <url>%2F%E6%AF%95%E4%B8%9A%EF%BC%9F%2F2488902409.html</url>
    <content type="text"><![CDATA[var player = new DogePlayer({ container: document.getElementById('player'), userId: 118, vcode: '14a9a2deaf56cdbe', autoPlay: false, vtype: 5 }); 视频时长：1 分 51 秒 | 消耗流量：约 15MB 我要拍毕业照了 路途遥远 天气变化无常 来不了也没关系 真的想来，不吝合影 微信告我一声 大家工作学习要紧！ 12时间：2019.05.06地点：北京理工大学珠海学院 大学四载，钻研程序 毕业相聚，他日再会 完]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 123]]></title>
    <url>%2FDay%20123%2F3447309739.html</url>
    <content type="text"><![CDATA[昨天是实习的 最后一天 过得很是平淡 倒不如说 这便是生活的种种 这几个月的实习生活 可说是收获颇丰 学习了很多前端的知识 也陆陆陆续做了几个项目任务 本以为,就像一切那样 安安静静的来 安静安静的离开 但在等待公交车的时候 莫名感伤 接下来 又是去往何处 ?]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>实习结束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也到了给高三学子建议的年纪了]]></title>
    <url>%2F%E6%88%91%E4%B9%9F%E5%88%B0%E4%BA%86%E7%BB%99%E9%AB%98%E4%B8%89%E5%AD%A6%E5%AD%90%E5%BB%BA%E8%AE%AE%E7%9A%84%E5%B9%B4%E7%BA%AA%E4%BA%86%2F2781860412.html</url>
    <content type="text"><![CDATA[请输入密码阅读. Incorrect Password! No content to display! U2FsdGVkX19vr4RMN2hlMC+KoT1YvE8huuTBMzefg/QZ0D2m4YC53mhdOy4LdI/OizaB4q2S7NjN/Y7/R74cvik/RdqA2YDVwsVEaRmaathPljjscDImodKFXYuE1QENZ1K5udU23OvQMEZcSfcNFYgJCaOZ9jZ0aR5f28yYo11z3+uvRz7hMszPadNkFU7gfU4jwT343ZgxwbiE/4h2Rf/4Gi6k5rm4v5xrWOFLIMC9pP8opUpEvHCxvFSi0e9bLl14++CEXtP8OTtPWGDNsIsE42iJ6/rabna8P4ClzGQXkdXtAKHxa7l7PATPYFz6J7YIZaFAOaJU0papNxWyYYFgNC+wB7/GKV2JKFwRb+hbzIK6Dmbgt0KdxIf5DmplwIjdOucH6m1FBCnXubzcudon8+DXNugh8NcJUpmKDxtkjLToqFDnhwH0MDK+DR7Zl22tEVfjIs7vm2CDRA0ABeMen0XOwLcW/CoDnYKVb9EsfT/04tb/LHAbuJ89yaVlno7hZHGXZnekwmF49Qcx+QGrvmAzqiYRoIYI7XEtjugbx+YrcbdAmpy9hcEwpucCxslIuofG/cY4bOXRxEzO0WewAj2rUcB1+zoS3M7BomIjzhR26lXV0LVwnPf+cRB4tpQdITrBWGgFtqxdHW0Ujw532RfzS9PutPP8IrT4RC0jEdVdF9d5gaTtEfsR6wilA7dlXaV4SHnyr1sBQOb4pc+RcQC3bm0tIn3pf7ZvWRYIgHY8CUbYXOCDSnKO6a0XEiXqPuuq9TiPHXC8lFl/Lxt1xfP50Z9HrdYQkdsX5XCYsiSy35xqDH5kKcSIWKoCCOe2fE+EcEIAvSVTTV6eqH89hrwEFQwXAIEkq6xEwsnkJYSEgFJ2IUyqwb3TbAO3ka7Kaqjy/jh+wJ0pc9GednWoldc9ceg50GgnLmzCuvv2oN207QSJOsMlIDgkNBWa/ILy6N9oEoFdub2dSWUJWwOKPUPJ5c3/pXa1DJhttIY8Eg6lF1Nze8/f1jUk68slveRj5GApuQqvUvzPBGysTUK7b3LwHBnjUaVT6x51GqpZITyoeUnBqBFDESq6usT5IGEtR8PDXNDBhmPIVeWP23nCkEwBx1RvilGzAYt/Wrh5cS6BboI6nkhoFI1q2D5Y3pZzmLTJQlyN86uS/3eYPrJgbO4vzTWJnuBCNfVrvBeXT3XeznLgTTeyqBbUPFZVSRoMlJbHn5I/5GX05182PSSnh7uLFX97bO72SD647W53gNc6ZKlD8BEf0ONpLsK0g0J45nOEx4f3GEsaLX+YDlO0fZmOVzg7PXIl5om/zhJhjn3/XFB5cTsAskoKuBXe4SwltfkJEwipH97edRuhM2xYZNT1LG8s2+nctjSzaGMHB1G1Rtv0LnOcRYdXGTDDf9bb8ar1r1UmBtaxjHt9+cB3HUPFJ2pgdzoIq4UruGIUmzMhzhnbmBLoZC1FFVHjP8kPV60Hn1yWGo3QloPly63vnhAp2xkWrs1AtfJQF+BHcvo4/ktrjUrjudVSVM+GD8b07HKkuN1CbRsgmQjxA/1dCuLgJk33pqpxbYfpKafeZymc9WrVDcs+6XU1Om72dDvYgsJvb4kOzHxhnuE7xMVv9nkqPqcFMP13ZPbedKTAVim2sBW0iI7pWuuVwbmAAEYUM7Q2kEijHxLbrCmqlTeEcSFnW5aqozxtzztszi+LgYQTTGj6ie7NgC8VC6CTBSF1WBTd69LUXV0iuUuicWbkuR0C2yL9P6Tzb5BjX6kXPn1skyFsOJ+juaogOuCxcF/RWcIGCC3cdfRLnXSN71HEVNUPNtCbyppDzmVu98H06mQXuSiWzt3V00us5nR+ar2CMurtVTljN3bouO4EiXwGKq1WUH8NLdeVkQmBkbupsy3mEv8XpMt60wODCFZRkLHcgXU8yPrra5ODyAX6k98nqhvESjMEJFZUAIyXmitDBiZsLZqwtGqRVEELnWnXRYfoSpGR/EVFWDEhblvlnicBv3LdIYivTYsJ0Y6aAho7BTORB4T54XWmScCwuIsJL1K1DYeP8RP+dTor31zJUALOD94h8aHYx6LIo4lwd5cNLncCdLr9OWf/p18vmFSW/oUPqOsRH0pBnMgY+Cc30dsr3Jxy0MZBpF191P78t2DqQDF8D07dDkN7lvvmDAMhtPXHi+fmMUBSaRioZgU12+A0rhbmntV2uAPJcfMW7i8l/khRDh9j86iQ4XvAQXi5tqscYerYXunv9jjvuNU5PuUWGdQIcN8AsRIiw0NtxEAQsxdbrdgQUsB7auIkr/AxyJd6PH1xraEjb1/WcWwFFrr9CKHaFiKYKzKNLdqAedVzigbFb/vcfHPnTCbYR/wrOTqBrE8cKe0yAlXCyBjx5H0TaZUtp9BATFCBWY50+/lTnbbeCLhVre+80XariUW0xC4GY0EVF7vWsf2xrKt/oaL1DV0A+pNDV8lry9qOoN0MdBDVw2nPUXVxfcm/d4QcjcaEn83GsQg2sMWcpUw/TF9jCAvcCdLZ+OqVKfslhhhHQAMMRFSo9K1IkrfPuJ6wQ3FDVNf8eEi+ypzNocrhgvQ3qyiH6WadsOM3CL57l6YzIMF49B/Z2P19eBe/oybLaIsxISDdUybj0SVHomtLoO9qDGDXFYhJXK1CbqOjSqmHFjvQbtRwNYzYTP130rs7mr5u/2Dc4wT3MBCqPDIuddSZX2dYp2FDSZqwKkUjnatLhSEK+WBzDyLWAYuxJ/V3p951U7eLUCYLqM2BmKfKyqhknLfKnrolFMsknEYgxMaSJexdkdqIYFR0/g9ZL+BdYVluSDOfVi+K8v+g9vbs6scgWulimFrj8jLeEk4x7qCzgTMopA2CYpRGYgTIFVE97OGNHHMlkidgLmpaTxgnxaXLTWS9WfBB25UQ1ri4E+yBcnBn2zOvthyU5nbE1+NKw18FbE5DET7eRVk9BrIP0qeiQ4g83Md0thtLA9LhDTxaoXddpNiHpjsMp38M91yNiZrl4Fi/esDMziB0bmC25mjvFCEuIuoZDQaxB4YMSX+maI5O6TM1qxUDmyox0IPftqy1Uej3hKy6HgY524m60iWzVpDK8o4MWHwGSXjprfYh0EDcVEZ9L3TQcR3GwfXPsQsszIAEzUAJ3ivlQmp19otbF3nEMiYoRepjArI/zbRxGm5r2Cj/jqm71dbj0pfyRqnhGnL/7gyCch8WnNnfBcvxqLII9gCEUX13AIcKSQ0SxlXWBbZe42V/ZzgGmZRR6LvjDE6BVGuLYMYjzY8eeyjwY5LxURm1Le71FW6WfZ+GmNEpYGrGoy3/v4/ik5XBCD5SVz4RisoYPNjWbHZX4Wt1pT7N8b20w42Uit6udJYkF7NbLIX4cUrCUADrqF6idGdTnyn/9ENUzzh9fyF6zU92R1fgVDgA3VQGWO6Neli92rqQdszG+6Ii19t2kGFwULXEW5/q6v81zLeBAz0l80yayV4waCQ1UQh7UXP2fRrAwmOWInBSN9VdEUTDRofPatgBmxUCdqyjpeGfCwYcsanjjGHUyfhCEBs6biUhhsWba4M/wDwjSg2bHRDHqdtLHu5X3GUlpTsSUekQylfJienisWQw0UdyTGrsqCjT3vaIuVtWIckVRpTRX5L8o2DjsvAbBkXo5rt6uK8XG3f2am2byUPsIysiPR5AwR2SHysCbAFI7WBFTW9WaeU63N/AazK7FZLKOVZaQ4YC5qgBDIDAf1+Ye5/M9JBLM4dbZIJo4PfFf1rNB7A9tYCFuImfRAYVmPTLNpN16o4mvYmT9yK+fQSswga6KEr8/mXHrFHl4yqyZwhICHPgCp6EVM/fgYxCZ4R6yR3EeqTSGiCIQBIt/nfC0NwEefcrGzmUGbgc6hfWl055HtkRgZxEH1BqYBO1AFmriRWiPDAUoudnE99JrpI1t3Cg0UAdBc0rh7TW/xwKx7XjlCky7UutCfJxtZekKr2ngGOmFEuM2c083aYTG9p5anY2MqXhx50LRqMJN1DB9sNYpk8VeegA/yMKUtSJvnOIsCKslkXYE9pbgGcoQAfaZnq27hJa7ujOZKVC2uvgEf4IxXM1NWkCpNPBo2zPH2b6/4dEa07wMLpqLMR31dhXImhfs3fzVvHKQWoT0QKA+w/SPxa1eFXNStlkLoBrUDxDqOudVgFnaMBB5RNeuBAAMkpEI0oZTT3htNRMSc+3Ufrxp7eYzbPE4RNibP9rW9OxPg37zWuZNSx9lkiwvhe8xd3MaBmsIBWAcUBqKd5fE/+1vPFoB99EpKax0MorMdEoTSUHW+umSCB1iuVNO9/l2aY9CkT3P6Ma9KtOAyzjLiXI+iU4hvPJRovR7yqp0I6bBSzyNHbE58RF91K3X+MSZ6WNwctp+J/vfgDvTN2xWZmKjLJmA6OUNSXYnU1aOpr6e82V9uzi6X9yGVOiTuZV2BQIcx7PUqmjtoRu9nv0CzUFT0wvDeXlHWAQUM+8NdtCUeiHLlCA0i1ZUFpv6Z1YkZF43b+R3RpoKsu1SehTxa4dIL7WbmQQdhxeuyBfrdK1b3rUBeiO+TEpyimQCQqLxN8itDXFtgjUDBitk9w/GAxN9EmqHDZpdbIKiOdL4Oz5GdurFsmVoC6eQw9HFEhwOL9ZMckmNJrzlO4amy4spKi6npr46AQWqrml3oRDzARj4u27ZOTUxttlma8VxO9FikhPlGKOdkhhgc0PAS4iCzz3y60GmPOpypTjye+O7/lP2ACNQogWTSgBe8ggYYPM5h9MNqFZXgPvi9HVXMJIKKikBUn9pwq3km3AzW+EG4aGBLFOYGmENcLX04P2icrbQdpgUlqHNj0cOEE+OR9EXRxEQ26738Zy0vPgVsfcbmkEMQzjtEn0TWUzepzqTFZSypgOO9tBmKjA5MIwZ/iEDfj6yAkG3LCloOFGdDg58OaFtNe5V6G01MikTjW3b0n6f8nwYIsdGpCkb1xoWf2w2Ioz0mn4cQUXz3k4/+voPbxEjg/G61GeJEnxXRXWUy/84KdZr5cqnl3JWKPqyMmZ91kBOldp5rhbk8nnE1l0aX/LRXKYuBJXxyE2PRoHQQ9eCCFplxvEiuTcVh+gm3psaix/fwFYRGOwWCdmQ0ym32BjUV9a5/2RoIaB7VsqXMbXaaZMP9+g232x20jtrbfNFcZj4aWSUQnEP2a+65Ir52hUCB0/iIYkMyajulFb1u57iIGs8MOI4FcvJoJVXzOAvQKmqsN15809qHLdZkbASeo+c6TDsG3prx3BX2mnkP1+AoYGCGOIjhPQxYHPUeZDdDzTK57bbUVgRLQNYs7bojbU3XjqHm8/jLjAVSSrs98KCxmSTlzS/NBAj314ZJ3Q5rw5KFkzD0m94Ia3oYWsaw77cgczzsEq3kp5UQMAAyuRPCRUL9GqkkEdR9YaEpsYTRBR88UjbX7ZRWg26qc9DgOSXwMqyMI09hzCcR4o3ZumsjI1ecU8OXrWu6pRECDpDs0qlqE4FUYsktIm0qi3QEVah1s87bDpGVytyrlRTV5ftTJ8Z+Vpu4W77kRxGlhfgRUr99ZJSzdTdraXn5R4m4f/YFZFo1PZr/g9VIUixS4YfnmiDVs8b1Ggywz75uzms/G7n5uFPp/qoaCaowhy9vVdxraI2WsMIEf8ehAqyrEFkglkNbhxLDg65rUMBNVRWtqgzJK9idqEzBBZIt/Z9MUHcYybX9fDbLrtuB6pq9RHvO3QDnomHljUOM8+LUmQaTFHhyhw5mvVcGMULdEMOsxWDxZ8xueKbFDTQJ2c1ilCA43W98xBOXO+G4ppwVnUE1MMs0yXyYBojCtBG2ooQDXvMal1VmPMRCJAy7J5bNdK2PXSoQ+lk/7ZHMJiE05S15+26suOwWldp1yjnDxL4rXuWW9r/9lVsP7gQ9948bxXwJTfzHPb2WnaAh8YpK9/ldmEJGeuAzxBRgSpHKAXjq3cj53W3Ry0r8lzDDyD/59rNF84pP3z4JonCM/A9Mtla10xHWxFXbSDKSeiH8gXuuCEWUJ1GlIYaeV4pAHRlEUWnDzbupCsBR3jibphRMakUEAUJbN9zd4qreZp11AhjaiA0x3jSwwZ/AxX/xLylroND/5tKYgepxwPubCGGWZIO0Qif0qV9dQdM2L96YHnht9Mfd9ZcKkfeTdvaqJMEmpWXzS5xVr6gOkD10jo86qWJZoAk7kF2DEq7JercmpTkgRJM65zEjZlGSEXJQ6CPLykreeyTpxDCWUdYaolIo/uv/2tww1J3qwhaCIIat35bM6TFFB/ZLetk2MriubovHaZ+SY9myi1q8AbXmimUKDQ9j8v+0tLQgvxFYaFNOEOlCrCZMzYRUkbfC+/Fu84BQSnmibbDp8a87M5F+DQ1D317N6F6++00yUCFKusc7PInHoyvSVaSAd0+9NsPAqR00k89hTyHd5IYMqHXHv4oguTfBzDCev+J88BUzXeZOWxiKirxKnv8TGqGaya2OBn3XoJrfik9Wvt2MhTRtWV/clOjfBNKZh6YhsqRrN6jIIf79ztnzAFRf6g0KzUv5er2lW4uJA53D6nMWdsL+jcY4lyGLM8OMVBhO+fYiHIfOHaZsBoXFeMEKr1gk5SJpemtdGK0bJ8zQr4h2UX9bMwlFwWqQOkyuhKpBVFOrnG6/ap7+/MrDXQwVv2QU+waJmeNyueavnWYDtUms80QzNM7SU+7rGe0HJyB8NocgXdZLdp15FjsUBrZmeCdyMwKYU4i/EVzt9yN3lNBHA87VBrpxnlmkuE8qUFraIFXXnAXlILDWWYDSo1+11XGS9KMZFto+TYvrq8WxOyhdEo8bD5u33UHfyU58mSHP1vvXjS2DnX2weOz4mhJh+xOrXJCzx4LBPUueGqzHldv7OkHR/ZVvV5+fBStToXQM8TU4Rk+ESnZZloltHhMDKkJ/Miq5dZ0Df71tO+8JhRp+1fIxv428LI+9cheHFohHA020Lmwu5XBIYst1UDQB5JmI93g5pPVjB3wsQ2kxKFOl431ES+c+goYePDxceuGlP/D93XJm14P1WeaekZJ182ANHgRC7DmjhtW4kCUfRilm9cGxNILivAqd4Yr1Na0aVxqkzErSbWJ9pry3ah03ZL2m18JmLu6JcUzTzd/HybQAiYqwmv53gZ4t2YtjoDxGMQxYRYSiNOdnN07YYd8mxB/+iWUPupyy1UYp4VfFSv7jQLR97QKr/wj9EqlHA1J9H6plHNzxTspFep4G8CwMEHOcrMVy/9Q1S0D1nEDNAi91Fc0JyULAVJ/UsUc/6PHnxayh69Wbi0wfd6CNOMoq2Te/dpqkW7BmmAiZKci7qlaSl5G8xO71Imws0RD7V2ccveCx0D6w+xWW3XnjAX4Sfjbld1MgZlT1bJjQ4528VT7UsKPg1rYjcTwP51SKSDrxQWiYh2y98V0TaJvilrLzyKKxLZ6QcnHHLak/4aglV2p4iHvZYwIajrEYXn7IJxzu2rnyKSZSjsBD9WptkyUGvanlukfCCgNi1+q5ZgJAi1ET8XBcLQMaij6HbFDBfcdHX0DfXp6g5igYu50YysFNnxUMro+44JBzsxOC0P6oEbMkFpaIZEhRTH08IKRfgTebVwzpnpbowUOnZB9dMusPNj3Tv0OpZ29z2SrE2Zckfz8K0H2ZOvxNE1BJBMEiPl2eBlwu0djZ3RjYqsQEencZ//AOsv83vIxHWlNNGban8zFw2WII8IUzQVdirmCZWxKz+EtLfKAgcZjXvQbj6qu3szLKsI/tqe248aSAlk9jL56GLqiNVEaDDAlkY0tFT9OzkSBMqav6zveXXxIiCR3ck3aP/x9t3+7AZg87mo9V0IjYxy8HnZknPCM7TC4F+0FzVpOTOUhnSlIQQb1gZ+vXBjgpV96giNW4QZ71m/fsUHHsC5oGJUHixdWltyewF48kRROE29Yxp9eKWIyGrqfIbpxtEnJSeBFL1Pmtugciiq8h4H72tpNXiDPlv2jO0wjuqhU9FxgKqVwIzb+YrOK2/Vypbde0dI6ARVycVM1LFU0DoiFw52wM7F5qRD4CHdPQ72siLbIMzl+iaAui0JUJlu5oYwzCLuYGsyoh0ju4Fb3zCDXwgvQohYyrdwYCZTbAJpcI4g5su9A+IxJ3oCo46rkXzVj7WKF0IAFIM85iK/xW3lsmheoXj0jbjw26fAJmU0U8ZZJMX+YjU9JBCGPWcENmirUMTQuWbqlsHvZjNoyfqXcxKVGos4fdfayVh/3y4Tbwkp4XWu7U9WtbDQds32Biap0K9Yp5LoXqp4mnlo4GEvdosEpYDy6l5adt4DOz1VBrPdsJfNXKaAnu5oQZnU0Ef8Ui8oEQ4HtKmuRB4YvANbtN8TUz8/1HEPoyJb4yaCkg2TLpByIfpN74ZBjJ5vxAZejiKtmiKkvJf8hrMQJ5oxKWOPAnvRAooYegfjIHDC2an0/ZKZUq7SYZsAnbvCnLbvXsNRwPuEKqKcxvpUOiLo5sntDfqxIHpX+YzdmOK9q6Z0N5xeeAzykfm2ceua9QjUtfsV1dzsC6e9PV824XjJ2y8fL9uybJONGTl1qwVupngBGn7iHDEVNrSRCGN9YlZ2MdrsjbPwAv3ktpRlPaFwd7zHuT0IppbLa57DXjGpjrcE2tGxbZWHcrw2ZwwR2idD7UXjllF88TdcXBg2R+UWdoqJrMrhzpn2yObMm0COC6jqjUZRdjnXrWbWEAFOvc7Ql0kq4d2cazxmKuwzqBO57n7BXdZnLI3zwyVs5mdXxWZGkRhmYY/DEkg6YDBk3YT7M3c+TjMLaB0gAka1SrBtrAAmBibQZ93TeXzt+MjiCkHJtozoezVxpPwEO40XYJPcmRHW0j3GVZAcdp5QXl+36MiWcz2iQv3Owv7VFBnJ/BlC6/R3T4gb23eMjA1JBbDn//8uBr6oqkKG6H7VEzVPTWCalbs2V6SRaLZJ6O3LOvATZExaJmBxL9fhkHacV6F0Poc/zUj+C1xCl3DqUa6N/6M7R8HAj7FA9qaYDSLbpzmMI8WTVSWT3oE38JhfoyW3kR4OmwvBPwow/EU7CNTPWMXHKmHH3T8zs4C1hSKFDEXjvQwGl26EcTCM8Q39TdHF/HaMlUVCvw/IjgFvhIa+iYV87HGDe1+gmSQmlHA9Nb/PzZNmnU/BVZH5JOz2hsBEjfxIniBHmcxAp0p8g8PncK1Sb8MhJYJqZZPKf7kUrpQnfp8VoMyERNUgJcQyrIK1uPQ2ekX4mvmpJ/nmnxIOcPAoIKk5yMsDAAW5EKwLB6P6Mbq607Hq5LTs/mwDuXuAA2t+pezkw38MgDtkBKhijzZdSEZftJxQ+Mco4prIiIsAfA+ciOKo0W7enjvNLzpU6acPYy4RWddRTFJSTXR1DwH2Q4vQe5lTOl2hwHa+S94Ak5/wqmwMwkhe74YHty8X85o6kTpJ84xyhbBYa5dgqidNwCrCY7001KmRSEQmQavEZq6ELdISROfIGnS6JKCfr36ve0WJU78k3tZYwxIcN9N/IMeRajmLwafXEyvO9yUQMDEpbcNW9rexIru5IQrsJXdKJkmuOKehxfYPMjZtCQj8FudYRoKxJgPrbcc6B0uk2D/RZ0ZFFYz9OVzjFwkqBLYGdWw3qsOJGo8CmvwJbvhn1rDvSbQSdFTKBa7XW3PMEZCFwGLqWcLeamuKOEvK6FHV+EnoNey+NubexGSLONXGT1jr77uZotkRdFqdWcOySW3YK41Sin6uGDgR2vHM2BpIus/w13dA7syOZnO1LoLwbC0BxEq+Cc1VyabtpxgDZNN5BcTjFgxi/5mndFFK0TGrDdF+xvhnHc+euLIaY3P+1zPzTSYt+OkoVMQSkeD3bRkeDJxDCiMUmTOHVBe0PP8di9j7k/tggo6JRE1M7KqUlUl9O4Q3+U5RF/9+CcoKFVpiyBQv6Z+yjewWaI35Dwf9RkoC7j2ztLEIXU6BtjS+9u8wIpbYtAbuwEZhc034MU7MDeSR/GGk+36008NPrnXGmvq54bGssGTskkjRAsRyKxEreiWb7lMxJF0zZsFvs/XOc6/8+aqyfa3I1DK0gwmuThPICXFKsP1Bd21Yejc/WFG/V/RwiXEGKITATypc1wmqoSL8++Cv9RLw4KFagslgYet3vrY2zKGuT/Kin8tkIoSb7zeUYnFR7DBILbUhFDKD7Y+4JOVXBmwjyZyNvg/q5PR1NX9QKKuTMFEXp0ykEpA1d402eO1zbkT+QkIF5WT7fK/so/YUkQGYsZSrWamvlJo1IuKmEFetwrQrH0zhu8ALNwy3MybwhSJp1T5CNKHqslISoa88SPlJG40p8iwgBzfW9V+EY+IDBouCiX637IqqurNiDrQQwEnGqr4HzEI14xd/c5KwXPFfut8UXjJS2bGHgxcUahcHQJr0KllgsjpYD6xvjutIXSUkbAF713xlSQo7nX+6aHeRCgISQMye5z0kpNJOWmr5HZBpg8ZSDUknMEUUU51U3Bfst+rklXQw6QAQwjpthvKCvRetOcshh196nnS5g+QUVUmSdrU=]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>高考100天</tag>
        <tag>建议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过分的自觉——恋如雨止]]></title>
    <url>%2F%E8%BF%87%E5%88%86%E7%9A%84%E8%87%AA%E8%A7%89%E2%80%94%E2%80%94%E6%81%8B%E5%A6%82%E9%9B%A8%E6%AD%A2%2F1850346193.html</url>
    <content type="text"><![CDATA[var player = new DogePlayer({ container: document.getElementById('player'), userId: 118, vcode: '8c3d093988816a39', autoPlay: false, vtype: 5 }); 恋如雨止 未完…]]></content>
      <categories>
        <category>漫</category>
      </categories>
      <tags>
        <tag>恋如雨止</tag>
        <tag>青春</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coding持续集成部署Hexo]]></title>
    <url>%2FCoding%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2Hexo%2F3417542952.html</url>
    <content type="text"><![CDATA[话不多说，先看效果图 技能需求 Hexo gulp git 首先，你必须会以上两个技能，这不是一篇基础教程，等你学会搭建 Hexo 博客后，可看这篇。 对比 以前搭建好博客后，在 cmd 控制台输入 hexo n “博文标题” 创建博文。写好博文后，使用 hexo clean &amp; hexo g &amp; heox d 即可将文章推送到 github 或 coding 的 Pages 中。 这里还省略了 Node.js 的安装过程，当你离开了自己的电脑时，在其他电脑想要写博文或修改博文，需要重新搭一遍环境，有点麻烦，不够 geek。 现在你只需要将你的博客源文件上传到远程代码托管平台（推荐 Coding！）然后使用 Coding 的持续集成功能，当你再次上传你改动后的博客源文件，Coding 检测到你的博客源文件有改动后，会自动部署到你的博客中。 流程图对比 一看对比图，好像并没有省去多少步骤，反而更麻烦，其实就把环境配置那一步省略了，而且还能把你的博客源文件保存在代码托管平台，方便多了。 步骤 1.Coding 建立私有仓库 在 Coding 建一个私有仓库，用于存放你的博客源文件，并且获取访问令牌。 访问令牌用于持续集成中将你生成的博客文件可以 push 到你的 Pages 中。 获取访问令牌登录 Coding–&gt;跳转到腾讯云开发者平台–&gt;点击个人头像–&gt;点击个人设置–&gt;点击访问令牌–&gt;点击新建令牌,填入 令牌描述,勾选 project:depot 读/写完整的仓库控制权限,点击创建令牌即可。 2.配置持续集成文件 Jenkinsfile 在博客源文件仓库中，右侧点击持续集成–&gt;选择触发时间为：代码更新触发–&gt;选择触发方式为：推送到分支时 触发构建–&gt;点击简易模板 Jenkinsfile 配置代码 12345678910111213141516171819202122232425262728293031323334353637383940414243pipeline &#123; agent &#123; // 此处设定构建环境，目前可选有 // java-8,python-2.7,python-3.5,build-essential,ruby-2.3,go-1.7,node-10 label "node-10" &#125; stages &#123; //获取博客源码 stage("检出") &#123; steps &#123; sh 'ci-init' checkout( [$class: 'GitSCM', branches: [[name: env.GIT_BUILD_REF]], userRemoteConfigs: [[url: env.GIT_REPO_URL]]] ) &#125; &#125; //使用npm安装所需插件 stage("安装") &#123; steps &#123; echo "切换npm源" sh 'npm config set registry https://registry.npm.taobao.org' echo "安装Hexo" sh 'npm install hexo-cli -g' echo "安装" sh 'npm install' &#125; &#125; //部署到github或coding的Pages中 stage("部署") &#123; steps &#123; echo "部署中..." sh 'hexo clean' sh 'hexo g' sh 'hexo d' echo "部署完成" &#125; &#125; &#125;&#125; 配置好后点击保存即可，会在你的博客源文件下生成一个 Jenkinsfile 文件。 3.修改 Hexo 根目录下的_config.yml 文件 注意Pages 仓库地址跟博客源文件仓库地址不是同一个。 打开 Hexo 根目录下的_config.yml 文件，找到 deploy 处，修改你的 Pages 仓库地址，其实就是在原先的仓库地址中加入访问口令，保存。 1234567891011# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: //修改成你的coding Pages仓库地址 coding: https://用户名:访问口令@git.dev.tencent.com/zhangsan/zhangsan.git //修改成你的github Pages仓库地址 github: https://访问口令(Token)@github.com/zhangsan/zhangsan.github.io.git branch: master 4.将博客源文件 push 到博客源文件仓库 将博客源文件推送到博客源文件仓库，博客源文件仓库检测到改动后，就会启动持续集成，将生成的内容 push 到 Pages 仓库，部署完成。 BB 几句 这样看起来是不是有点复杂，但是比较 geek！同时又能让你熟悉一下 git 操作，顺带学习 Jenkinsfile 持续集成。 这些只是工具，写博客关键是持续的输出高质量的文章！ 完]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>自动部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万历的无尽孤独]]></title>
    <url>%2F%E4%B8%87%E5%8E%86%E7%9A%84%E6%97%A0%E5%B0%BD%E5%AD%A4%E7%8B%AC%2F4194258384.html</url>
    <content type="text"><![CDATA[初识 刚开始知晓《万历十五年》，是在电视剧《人民的名义》中，在京东购得此书时，并没有一口气读下来。这本书断断续续看了差不多一年，并不是我读得慢，完全是出于懒…不过，总归在前几天看完了，谈谈我的感受。 初章 公元 1587 年，在中国为明万历十五年，论干支则为丁亥，属猪。当日四海升平，全年并无大事可叙…总之，在历史上，万历十五年实为平平淡淡的一年。 此书并不是史书，而是由后人黄仁宇先生所著，不同于史书中较详尽的宫廷记录，作者根据各种历史文献和自身独特观点给读者展现了不一样的万历十五年。 孤独 我为何说万历拥有无尽孤独？ 万历皇帝从十岁失去父亲，登上皇位，自小在各种礼仪的规束下成长。从隆庆皇帝驾崩，万历穿着丧服接见臣僚，按照传统的“劝进”程式，在第三次才勉如所请答应登极。黄仁宇先生称这一过程：“这一番推辞和接受的过程，有条不紊，有如经过预习”。我所见的是一个十岁的孩童过分成熟，虽有背后所推动的臣僚，不一定全是自我意志，但默默一人接受着担负起“全天下”的责任的命运，过于沉重。而这仅仅只是孤独的开端。 根据皇家习俗，万历与生母慈圣皇太后会存在一种无形的距离，母子之间的天性交流变得更为不便。万历只十岁，与过世的父亲天人永隔自不必说，而对于活着的母亲，碍于习俗，无法得到更多的天性之爱。 万历十四年，万历皇帝册封他的爱妃郑氏为黄贵妃，并不是首先授予皇长子的母亲恭妃王氏，这种后来居上的行为，被当时的臣僚称为本末倒置，而这个小插曲，成为了一场影响深远的政治斗争的契机，导致了今后数十年皇帝与臣僚的对立，影响了整个帝国。 公元 1582 年，元辅张居正溘然长逝，这个在文臣中拥有至高无上的官衔的张太师，就此陨落。万历对于生前的张居中无比信任，并在张居正死后授予了代表位极人臣的称号，而后对张天师的清算运动，不禁让人唏嘘。接替张居正继任者张四维的首辅申时行温和谦让，他把人们口头上公认的理想称为“阳”，而把人们不能告人的私欲称为“阴”，就算如此，也未能以阴阳之道调和万历与诸大臣之间的矛盾。 其时，海瑞——古怪的模范官僚，戚继光——孤独的将领和李贽——自相冲突的哲学家可谓是万历时代的缩影，作者通过他们三人，阐述国家用道德来解释法制，期间不乏宗教色彩，而后种种的光怪陆离不足为怪。 万历皇帝从继位到万历十五年，励精图治，而后万历十五年后开始怠政，期间的万历十五年正是关键。这一年，他想立自己最喜欢的儿子为太子时而不得，终于清楚认识到自己的存在也是一种朝廷党政的工具。 以上种种，我感受到了万历的无尽孤独，权利通天的皇帝也无法打破当时的桎梏，颇有“造石悖论”的意味。 终章 1587 年，是为万历十五年，岁次丁亥，表面上似乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安耽乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能在事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败而兼名裂。 孤独恰巧不在善恶之间。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>万历十五年</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云图床]]></title>
    <url>%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A%2F2523873752.html</url>
    <content type="text"><![CDATA[中等意思 大概是前几天还是一个星期前收到七牛云的官方邮件意思是测试域名被收回了我不以为意 然后过了几天看了一下我的 blog发现我放在七牛云的图片全部无法显示我知道这时候事情似乎有点大条看了一下可以通过绑定我的域名来重新显示图片刚好手头上有xu-lin.xyz 这个域名于是绑定替换 blog 的文章的图片(幸好文章不多，图片更少)虽然这样解决了，但是那个域名要用来做毕业设计而且要钱(不想续费)所以还是找找有什么图床可用有道云笔记的方法过于麻烦，暂不考虑]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>七牛云图床</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瞎学]]></title>
    <url>%2F%E7%9E%8E%E5%AD%A6%2F1376126162.html</url>
    <content type="text"><![CDATA[今天跟昨天一样上班 挺有目标先学 Node.js学的还可以基本入门 因为这博客搭建用的也是Node.js 所以环境搭建轻松 倒是配置sublime 的主题费了功夫最近越来越视觉动物 下午尝试IDEA 练手SpringMVC 框架发现嵌入式实践的人脸识别系统有这个框架雏形 SpringMVC 框架入手也挺快 接着Maven 项目管理工具看了很多教程基本了解 今天看来还是很充实（并不） 在二饭遇到 熟悉的人回来时QQ，微信聊了好久换了几拨人 看来上班话不多有人时尽扯 大概害怕孤独？ 不觉已深秋]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>SpringMVC</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 0]]></title>
    <url>%2FDay%200%2F11984419.html</url>
    <content type="text"><![CDATA[实习第一天 昨晚看完刀剑神域 Alicization第 7 集接近两点迷迷糊糊就睡了 早上狗子的闹钟吵醒我 可能是要去实习所以睡眠不深 醒了以后再也无法入睡 八点起床到达公司8:40 分 并不是脚程快是公交快可喜珠海公交从今天起1 元就好 等到 9:30人事带来协议签了之后快十点 leader 也忙俩 java 开发实习晾着 等电脑装好后leader 谈话明确了实习方向顿时稍有斗志 公司里的师兄很有热情 午饭后高凌盈盛智创打来电话已入职遂拒绝 不过充满期待的 day 0无事可忙草草收场 明日好好学习先前端后后端 乱搭 回宿舍后跟仙河紫妍有一搭没一搭聊着 今天高中英语课代表（女）结婚 我纠正仙河朋友圈高中第一对 阿朱和金英儿子已爬地才应该是第一对 吹吹水一天也就那么过去了 完]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>瞎聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所知道的ZEALER]]></title>
    <url>%2F%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84ZEALER%2F506570495.html</url>
    <content type="text"><![CDATA[我看 ZEALER 测评应该有好几个年头了，从高中开始看起，那时候中国的手机测评几乎是空白的，而 ZEALER 以其专业性给我带来了很多的手机知识。 ZEALER 刚开始时，只有王自如一个人主讲，他本人虽然不是计算机专业的，但对手机和电脑等数码产品颇有研究，应该算得上是中国第一代的玩机人。看 ZEALER 的视频不仅可以了解到最新的手机等各种数码产品，还能了解到很强的专业知识，比如手机摄像头的 COMS，各种参数的解析，而这种解析不只是停留于表面的解释，而是在视频中做出了形象的动画加以直白的话语。 而后，雷军投资了 ZEALER，虽然王自如说明了雷军的投资对公司的运营、决策和内容不加以干预，但是一家手机公司投资了一家以评测为主业的公司，这事看上去就有些膈应… 果不其然，ZEALER 评测玩起了春秋笔法，对于魅族和小米两款手机，虽然都拥有同样的缺陷，对魅族是大加批评，而小米则是一笔带过。这已经不独立不公正了，当然也可以说每家公司都有自己的观点与评判标准，对于每个品牌的要求都不一样，但是这就是明显的区别对待。 再然后，就是 ZEALER 惹上了罗永浩。ZEALER 对老罗出的第一款手机锤子 T1 毫不保留的批评，老罗不忿，在优酷直播“约战”王自如。王自如好像并没有准备，被老罗疯狂“插刀”，直播就是王自如一直被老罗怼，不欢而散。其后，ZEALER 开的第一场发布会（在“约战”前开的），对公司的未来转型的计划全部被打乱。 这时候，我对 ZEALER 的发展就不怎么跟进了，中国的评测机构也多了起来，我看的口味也杂了起来 ，有体验派，有学术派等等。但都找不回当初看 ZEALER 那时候的感觉了，新奇又有趣。这几年。ZEALER 的转型应该也算成功了，不仅仅局限于手机评测，还跨界到各种各样的产品，连汽车都有好几期评测。当重新印入我眼帘的是，ZEALER 拍的关于王自如在日本的差旅日志。画面拍得实在是太好看了，各种各样的动漫场景与不间断的切换，感觉又回到了高中以前的那个认真做视频的 ZEALER。 而这次 ZEALER 发的新发布会先导预告，讲述了王自如从创业开始的辛酸，让我了解到了人前酷炫，人后唏嘘。总之，还是期待 ZEALER 的发布会，期望他不忘初心，少做点妥协，越来越好。 ps 今天盈盛智创公司找我面试了做区块链+人工智能很是心水待遇：2000，包住，广州黄埔区唯一担忧能力跟不上而且一进去直接接手项目还是再接再厉]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>ZEALER</tag>
        <tag>区块链</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宿舍聚餐]]></title>
    <url>%2F%E5%AE%BF%E8%88%8D%E8%81%9A%E9%A4%90%2F2816460104.html</url>
    <content type="text"><![CDATA[北京理工大学珠海学院 当年还在抱怨不好好学习转眼间就快离开校园 前几天远哥总是不断唠叨就快去深圳复习公务员考试 我们也趁势不断提醒远哥快要离去 于是今晚出去聚餐 聚餐的地点也不远就是首图新大门的对面老崔烤鱼 这个新大门建成该有两年了愣是不开放还记得吴老说学校要改名 可这几年过去了风声也还只是风声没影 聚餐时祝酒词仅仅只是考研考公成功 玮儿备考也有半年多了总之6 人宿舍只我一人出去实习… 那么久过去了多少还是想保留学校的美好想来想去在回来的路上路过弘毅楼时拍了张照 照片很糊远哥和玮儿说道搞得像毕业一样是呀可能快要预见快失去的东西趁现在还想保留会完]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>聚餐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[还行]]></title>
    <url>%2F%E8%BF%98%E8%A1%8C%2F1431678329.html</url>
    <content type="text"><![CDATA[请输入密码阅读. Incorrect Password! No content to display! U2FsdGVkX19lxWPhTo05/nrEB7jxxsXUd1tT7oqpVs7lxJKznqkvDW8ZMIGJVBCjFVDLeQm0byOImcRnPjgawQmFr2BAlLtNi/mjkXR5l+9GDB/0Zzb5gUrXavlVFSNtuCYJI4lZqiTPWlIiyt0sVYz0AlzX1CBHynXZmelGpzd/7gK4HV8aOC9CnAeKyNxtn2jzFIIzpGnyPD5cpEsfOlOuWNzU1PR2Ots6A5OZbori9icIVOnmXcrouMh6QuhsalZ6KumDbzK9TKgFiI9w3RKiGTFY/njBesWJ6Arg5VFnou0qZqGBmBy9I5Da/sKQbnaEluqosovziOT6WEDCJEEDfNJVmUhhgwhn7KyRMPqIvPh4KItwd264zuFZma2dxcFgBRzvm6kPg/irF0Cc/W/ueUrt9I6rsNeSsnP7iiJ6lQoj0pqV75EHCR0+squ/p4CMYUOkxt59wSJcbz3ubr4R6g8ooZPJn+/si+TX9X/7S+rE+zvHjnAVQBB1yro2NVzd7M7rBfzaYZrXYTx578nG1m6ybtoJZzW8LVl0Oeu/oYgrytMyVwY7wmGOHFQ1gRUsHv9wDAboRox5Vjd/ONAkFO8LZW5gZ/VrpvSZ7R91IhW2R8hsXVWJj0LJGmDV43mTp+Atq/J6jsmYGOt7O15egyiZ7wWkaPvM90swH1vrlERLEUrDSc6rcl76V7U4SG+LA7BttrTjz3cM7ByxQp7oISiNShs8usW+SXFFeXQziCWdfIgJ97umvpAi0T4bkX4er8fDiad0z+MNLWiwDf6ufuiEimOCNFavonFeYeS6UOMg79WGyqlMiTmy/SpS2iNK4U/sBse+5/tYvZ8ukT4UxOFtlAATiDBfCExZMW9KwuVaiNci4coc66xH7MiYcA7hPZns85mYemQ0aKH74U/RKMmmEFYtBm2T97EuAsFwnQsl9vCjiOFvPypFB6WdNhEGEoZokoCuiQ1lM9jRk78ksZWq1nJyqhnropTHofM4m8e7kdsIPuQPpayV8trYJM8QqCzHee9BLdEIPay2fJAPipDzExct4MuT1oO3haJnvLRGByYgRnQ/NValcdlcIREAfMBQWkxAWsGuiEkZOp668UBmwlUc4BvpiMshOO/OxB4Pjpl5b7Ux/JfGV4tbPljFHtDG+AIEPMTVkuwLv/kkpLKNZ+O6SWJ+uLw4H1XLscqlqFKMW9RZ7zwE3bMJ1U68nejQ56EFhDsx9RLhivgesje++XLJdwvunu9u1miZZ3o2VeksLX7hKqqbAB7d2hXg2W/zrJgCeTMHPHw/pkErIJoFW6l1LGtugIJejLqEJ7IsZWEwXDWsPf4CIkOWsBnbdOZoAtBRnlTsUQ/PKEjZY437beY9xdWvS9hvxIKqSJOSJESM7uSxQnSgJUMmpDtos0b0DZGPJQ6AFAI/udiVz3X+vYjYVMbYTvzr7z0=]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
        <tag>实习通知</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全自动部署失败]]></title>
    <url>%2F%E5%85%A8%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%2F4143676012.html</url>
    <content type="text"><![CDATA[忙碌了一天 想实现 hexo 全自动部署的想法失败了 哎，还是技术不精 等等 coding 的 CI 看能不能起死回生 完]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
        <tag>全自动部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无事]]></title>
    <url>%2F%E6%97%A0%E4%BA%8B%2F2503598047.html</url>
    <content type="text"><![CDATA[在阿里云 1 元 买了 xu-lin.top 域名配置域名废了好大功夫忘却了学习 天气倒是挺好没有出去逛逛明日有空必将游玩说话间到了明日 人生世事无常这无常仍旧无常下去 妹头最近对赚钱乐此不疲倒是好事不像我一事无成这丫头前十几分钟道了晚安愈发生性 安]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌云搭建v2ray]]></title>
    <url>%2F%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%90%AD%E5%BB%BAv2ray%2F2033633198.html</url>
    <content type="text"><![CDATA[准备工作你首先必须可以连上Google 谷歌云免费一年送$300去谷歌云注册（需要一张 visa 信用卡） 注册成功查看结算界面 创建实例左侧选择 Compute Engine -&gt; VM 实例 创建一个新实例，如下图设置 测试一下外部 ip，ping 一下外部 ip，查看延迟 如果 ping 值高，建议重新创建 VM 实例 使用 v2ray 脚本搭建点击 SSH 按钮 进入 SSH -&gt; 输入 sudo -i 获取 root 权限 接着输入 bash &lt;(curl -s -L https://233blog.com/v2ray.sh) 进入 v2ray 安装界面设置如下图 按回车等待安装完成（图中所选协议，端口可以改变，注意配置防火墙规则） 进入 v2ray安装成功后，在 root 权限下，输入 v2ray 在这个界面可以查看和下载所需链接 配置防火墙左侧选择 VPC 网络 -&gt; 防火墙规则 创建防火墙规则，设置如下图 在 win 电脑上使用 v2rayN详情请查看以下链接 v2rayN 使用教程 在安卓手机下使用 v2rayNGSSH 登录你的 VPS(如果你没登录) 输入 v2ray qr 回车，你会得到二维码的链接 如下图 下载v2rayNG软件 打开它，安装完成后打开，点击右上角设置图标 选上绕过中国大陆，分应用代理的话，自己视情况而定就行 点击右上角 + 图标，选择扫描二维码即可 便会自动识别 V2Ray 配置信息 扫描完成后，点击主界面右下角小飞机图标启动]]></content>
      <categories>
        <category>核</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
        <tag>Google Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Hexo]]></title>
    <url>%2F%E4%BD%A0%E5%A5%BD%EF%BC%8CHexo%2F2395102642.html</url>
    <content type="text"><![CDATA[请输入密码阅读. Incorrect Password! No content to display! U2FsdGVkX1+qIDvcoADN5OZpTgOqUyrKlQ/g5nXAPr044dnPuBcB0i7RQNsz9huY8RsJB7xlA5oNS02KJmATGAJ0iLtcClkWfRyiKlX2ttBDZhWsV2VZMgozP8bVGmn43WOraibA/WcL0MEJhX+uvHr42NJ9Y7CDpI4O37qGe8ZGh4O5kqAz8Tf0zvOEf1hXDjLsT6kDzmFEhEBvXDwX2pB+44TvvZr1VqqpWjRu2Up2+Hx0EOCsLU17hQksNgDgqEUXQgmEEs5GJYJzkYeV1atWzUzjDKd0kccvos8wX3WqCxFkkcLtCEcGheLGk9n6b5NYGbq46uE+gLJfG/Nyi6CchBudalwDVzJF2J846ySBVrhQ/jMClQwrVdKDLIDzjaQ+xk0bMDi3T+SFERjDl0cEtzxwnRtbUrHIePjhDPHRp7svZ8F0othUwtnjDKf0qtAwPlm57b5j2Z3fbHNnril/aVpwj80T55vN9eSucu29RHqODFzCrN/QmJuUn4E8z0atSlej/Dff0STPMNrUqiy63TSYpwKuUKe9pPvKrh6/yQJtyCyoEr0nqTiRG9rt5SilkjIJ6G0rzhywcFcPT1NugBXk7h+xmIi4L1W+T8GArWZxmV6gt1wDxdd3VDyo5wQNIu6pt54fpDG2H6znrrnmLQfUMNzjCt6w8e3mGmwYUcpSDeI+SXPfXrFqmf0t1R+A2IeT6HjeFYBRSfP8Tsr7JTeZfgYIDK6pf1VYRayuZB7e0/3ArQSiFrB3NVcNUPF0e29iwViGuK0ry+LMzbL+R0DneoNMzZ6913UqMsXOWhkvLZiOWQHpBOeQwJxm2ZQ+e8FY6TYORmwhId3Jtvw3vNpJu9oaZiZjJqrXqHOJP32DY5xK1nwufWJSuChjD+HzVL+N8PQKdnj8BQe9ezTRbdZA8kM2hxujzE0ikkXVVyWAP3GGPoQBsxXzPOIgOm8iV4ONJA93bCiOqg9+H8RdSSuL6xhFlw8gtgoYCcMUOhj4gF3c21Farcs7w7YCtFXWKuRM5O+08AgAldHJMSKCeS9AAFVSKhMaEiMVDiNbzx3l/vVWIvjg2oip25UCzGcDKwM0fmsYVPEUBtJg4C6D+U+7bFCCuVmgYyauawd3Ai/XML2YpUFx21KK5WfdRMt0mN1/jRySx+6s63hvDcJSnMv+MgoD6OLMionCMuzmuNn5EKvBTdCW8ld7VPH6wT9nVJ7g+OkGcRaTW37ulqUvrOrICSbI3a4a/hcPbdwclgf7PXm6F3mYiUEMxSdNLX1VFI9JrjD49vniZcPr59RdmuEH5bX5Xvk73V8Fhsw9w2ucIoVibOiJ/Zz6wB/wf1no8iw/KEZDzPDTT9m364BWyFcchXD7eg+plym/vjpI5XSybuJ4hYs0cR00n33EZRiqJU7hvqNgLchIxTa86eDgqMR5ukyFJVlHYL5Ti9NJA3ZYzkKHYAN8NzRRD50cAgukMXhMtMi4XU9DJBRQKW1jHA+ofnDbyjKjngmo5RM8j82x9qJOKwukfb36fH5bke1ajCxUSxP9nnNuaf/p/JSzcqCPfP/w/oM7f3hYrcQ=]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
